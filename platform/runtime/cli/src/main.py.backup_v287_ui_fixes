#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ü™ê unibos v294 - unicorn bodrum operating system
UI Rendering Fixes & Terminal Optimization

Author: berk hatƒ±rlƒ± - bitez, bodrum, muƒüla, t√ºrkiye
Version: v294_20250801_1735
Purpose: Professional terminal UI with multi-module support"""

import os
import sys
import json
import platform
import subprocess
import shutil
import time
import socket
import threading
import select
import re
import fcntl
from pathlib import Path
from datetime import datetime
try:
    from zoneinfo import ZoneInfo
except ImportError:
    try:
        from backports.zoneinfo import ZoneInfo
    except ImportError:
        ZoneInfo = None

# Platform-specific imports
if platform.system() != 'Windows':
    try:
        import termios
        import tty
        TERMIOS_AVAILABLE = True
    except ImportError:
        TERMIOS_AVAILABLE = False
else:
    TERMIOS_AVAILABLE = False
    import msvcrt

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import translations module
try:
    from translations import TRANSLATIONS, detect_system_language, get_translation, get_available_languages
except ImportError:
    print("Error: translations.py not found!")
    sys.exit(1)

# Import enhanced currencies module if available
try:
    from currencies_enhanced import CurrenciesModule
    CURRENCIES_AVAILABLE = True
except ImportError:
    CURRENCIES_AVAILABLE = False

# Import network utilities for security features
try:
    from network_utils import get_network_security_info, generate_security_report
    NETWORK_UTILS_AVAILABLE = True
except ImportError:
    NETWORK_UTILS_AVAILABLE = False
    print("Warning: network_utils.py not found - some features will be limited")

# Import optional managers
try:
    from version_manager import VersionManager
    version_manager = VersionManager()
    VERSION_INFO_DYNAMIC = version_manager.get_full_version_info()
except (ImportError, AttributeError):
    VERSION_INFO_DYNAMIC = None

try:
    from setup_manager import SetupManager
    setup_manager = SetupManager()
except ImportError:
    setup_manager = None

try:
    from repair_manager import RepairManager
    repair_manager = RepairManager()
except ImportError:
    repair_manager = None

try:
    from git_manager import GitManager, show_git_status, quick_commit, quick_push, quick_pull, quick_branch
    git_manager = GitManager()
except ImportError:
    git_manager = None

try:
    from communication_logger import comm_logger
    COMM_LOGGER_AVAILABLE = True
except ImportError:
    COMM_LOGGER_AVAILABLE = False
    comm_logger = None

# Version information
VERSION_INFO = {
    "version": "v290",
    "build": "20250801_1537", 
    "build_date": "2025-08-01 15:37:00 +03:00",
    "author": "berk hatƒ±rlƒ±",
    "location": "bitez, bodrum, muƒüla, t√ºrkiye, d√ºnya, g√ºne≈ü sistemi, samanyolu, yerel galaksi grubu, evren"
}

# Check for psutil availability
try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

# Global language state
CURRENT_LANG = detect_system_language()

def t(key):
    """Shorthand for get_translation"""
    return get_translation(CURRENT_LANG, key)

# Color definitions
class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    
    # Foreground colors
    BLACK = "\033[30m"
    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    MAGENTA = "\033[35m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"
    GRAY = "\033[90m"
    ORANGE = "\033[38;5;208m"
    
    # Background colors
    BG_BLACK = "\033[40m"
    BG_RED = "\033[41m"
    BG_GREEN = "\033[42m"
    BG_YELLOW = "\033[43m"
    BG_BLUE = "\033[44m"
    BG_MAGENTA = "\033[45m"
    BG_CYAN = "\033[46m"
    BG_WHITE = "\033[47m"
    # Improved contrast colors - WCAG compliant
    BG_GRAY = "\033[48;5;240m"      # Lighter gray for better contrast
    BG_ORANGE = "\033[48;5;208m"    # Orange background for Claude style
    BG_DARK = "\033[48;5;234m"      # Darker background for header/footer
    BG_CONTENT = "\033[48;5;236m"   # Dark but visible content background

# Menu state management
class MenuState:
    def __init__(self):
        self.current_section = 0  # 0=modules, 1=tools, 2=dev_tools
        self.selected_index = 0
        self.previous_index = None  # Track previous selection for efficient updates
        self.in_submenu = None
        self.in_language_menu = False
        self.language_selected_index = 0  # For language selector navigation
        self.tool_selected_index = 0
        self.modules = []
        self.tools = []
        self.last_cols = 0  # For terminal resize detection
        self.last_lines = 0
        self.dev_tools = []  # New dev tools section
        self.tool_items = []
        self.previous_tool_index = -1  # Track previous tool selection
        self.web_forge_index = 0  # Track selected option in web forge
        self.last_drawn_submenu = None  # Track last drawn submenu
        self.dev_tools_start_y = 0  # Position for dev tools section

menu_state = MenuState()

def clear_screen():
    """Clear the terminal screen"""
    os.system('cls' if platform.system() == 'Windows' else 'clear')
    sys.stdout.flush()  # Ensure screen is fully cleared before continuing

def get_terminal_size():
    """Get terminal dimensions"""
    try:
        import shutil
        columns, lines = shutil.get_terminal_size((80, 24))
        return columns, lines
    except:
        return 80, 24

def move_cursor(x, y):
    """Move cursor to position (1-indexed)"""
    print(f"\033[{y};{x}H", end='', flush=True)

def hide_cursor():
    """Hide the terminal cursor"""
    print("\033[?25l", end='', flush=True)

def show_cursor():
    """Show the terminal cursor"""
    print("\033[?25h", end='', flush=True)

def get_system_status():
    """Get simple online status"""
    try:
        # Try to connect to a public DNS server
        socket.create_connection(("8.8.8.8", 53), timeout=1).close()
        return f"{Colors.GREEN}‚óè{Colors.RESET}"
    except:
        return f"{Colors.RED}‚óè{Colors.RESET}"

def load_version_info():
    """Load version information from VERSION.json"""
    version_path = Path(__file__).parent / "VERSION.json"
    try:
        with open(version_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
            return {
                "version": data.get("version", "v236"),
                "build": data.get("build_number", "20250725_0254"),
                "build_date": data.get("release_date", "2025-07-25 02:54:00 +03:00"),
                "author": data.get("author", "berk hatƒ±rlƒ±"),
                "location": data.get("location", "bitez, bodrum, muƒüla, t√ºrkiye")
            }
    except Exception:
        return VERSION_INFO

# Load version info at startup
VERSION_INFO = load_version_info()

def draw_box(x, y, width, height, title="", color=Colors.CYAN, style="double", with_bg=True):
    """Draw a box with optional title"""
    if style == "double":
        TL, TR, BL, BR = "‚ïî", "‚ïó", "‚ïö", "‚ïù"
        H, V = "‚ïê", "‚ïë"
    else:
        TL, TR, BL, BR = "‚îå", "‚îê", "‚îî", "‚îò"
        H, V = "‚îÄ", "‚îÇ"
    
    # Get terminal size to respect boundaries
    cols, lines = get_terminal_size()
    
    # Ensure box doesn't overlap header or footer with better margins
    # Allow box to start at line 3 (immediately after header)
    if y < 3:
        y = 3  # Start immediately after header (which ends at line 2)
    if y + height > lines - 1:
        height = lines - 1 - y  # Adjust height to fit with 1-line margin from bottom
    
    # Ensure minimum box dimensions
    width = max(10, min(width, cols - x - 2))
    height = max(3, height)
    
    # Draw top line
    move_cursor(x, y)
    bg = "" # Remove background for cleaner look
    print(f"{bg}{color}{TL}{H * (width - 2)}{TR}{Colors.RESET}")
    
    # Add title if provided
    if title:
        # Calculate title position to center it
        title_with_spaces = f" {title} "
        title_len = len(title_with_spaces)
        title_pos = x + (width - title_len) // 2
        move_cursor(title_pos, y)
        print(f"{bg}{color}{Colors.BOLD}{title_with_spaces}{Colors.RESET}")
    
    # Draw sides
    for i in range(1, height - 1):
        if y + i < lines - 1:  # Don't draw over footer
            move_cursor(x, y + i)
            print(f"{bg}{color}{V}{Colors.RESET}")
            move_cursor(x + width - 1, y + i)
            print(f"{bg}{color}{V}{Colors.RESET}")
    
    # Draw bottom line
    if y + height - 1 < lines - 1:  # Don't draw over footer
        move_cursor(x, y + height - 1)
        print(f"{bg}{color}{BL}{H * (width - 2)}{BR}{Colors.RESET}")

def get_system_info():
    """Get enhanced system information"""
    try:
        system_info = {
            "hostname": socket.gethostname()[:20],
            "platform": platform.system(),
            "architecture": platform.machine(),
            "python_version": platform.python_version(),
        }
        
        # Get CPU and memory info if psutil is available
        if PSUTIL_AVAILABLE:
            try:
                # Memory
                mem = psutil.virtual_memory()
                system_info["memory_total"] = f"{mem.total // (1024**3)}GB"
                system_info["memory_used"] = f"{mem.used // (1024**3)}GB ({mem.percent:.1f}%)"
                
                # CPU
                system_info["cpu_cores"] = f"{psutil.cpu_count(logical=False)} physical, {psutil.cpu_count()} logical"
                system_info["cpu_usage"] = f"{psutil.cpu_percent(interval=0.1)}%"
                
                # Disk
                disk = psutil.disk_usage('/')
                system_info["disk_total"] = f"{disk.total / (1024**3):.1f}GB"
                system_info["disk_free"] = f"{disk.free / (1024**3):.1f}GB ({100 - disk.percent:.1f}%)"
            except Exception as e:
                system_info.update({
                    "memory_total": "n/a",
                    "cpu_cores": "n/a",
                    "disk_free": "n/a"
                })
        else:
            system_info.update({
                "memory_total": "N/A",
                "cpu_cores": "N/A",
                "disk_free": "N/A"
            })
        
        return system_info
        
    except Exception as e:
        return {
            "platform": platform.system(),
            "architecture": "unknown",
            "python_version": f"{sys.version_info.major}.{sys.version_info.minor}",
            "error": str(e)
        }

def get_navigation_breadcrumb():
    """Get navigation breadcrumb for current state"""
    parts = ["main"]
    
    if menu_state.in_submenu:
        if menu_state.in_submenu == 'system_scrolls':
            parts.append("tools")
            parts.append("system scrolls")
        elif menu_state.in_submenu == 'castle_guard':
            parts.append("tools")
            parts.append("castle guard")
        elif menu_state.in_submenu == 'forge_smithy':
            parts.append("tools")
            parts.append("forge smithy")
        elif menu_state.in_submenu == 'anvil_repair':
            parts.append("tools")
            parts.append("anvil repair")
        elif menu_state.in_submenu == 'code_forge':
            parts.append("tools")
            parts.append("code forge")
        elif menu_state.in_submenu == 'web_forge':
            parts.append("tools")
            parts.append("web forge")
        elif menu_state.in_submenu == 'git':
            parts.append("dev tools")
            parts.append("git manager")
        elif menu_state.in_submenu in ['recaria', 'birlikteyiz', 'kisisel', 'currencies']:
            parts.append("modules")
            parts.append(menu_state.in_submenu)
    
    return " ‚Ä∫ ".join(parts) if len(parts) > 1 else ""

def draw_header():
    """Draw header with logo/version and user info"""
    cols, lines = get_terminal_size()
    
    # Build information
    version = VERSION_INFO.get("version", "v236")
    build = VERSION_INFO.get("build", "")
    
    # Draw header with distinct orange background - reduced to lines 1-2 (10% reduction)
    for y in range(1, 3):  # Lines 1, 2 only
        move_cursor(1, y)
        # Ensure we clear and fill the entire line with orange background
        sys.stdout.write('\033[2K')  # Clear entire line first
        sys.stdout.write(f"\033[{y};1H")  # Move to beginning of line
        sys.stdout.write(f"{Colors.BG_ORANGE}{' ' * cols}{Colors.RESET}")
        sys.stdout.flush()
    
    # Line 1: Logo and title on the left, user info on right
    move_cursor(2, 1)
    print(f"{Colors.BG_ORANGE}{Colors.WHITE}ü¶Ñ {Colors.BOLD}unibos {Colors.BLACK}{version} {Colors.WHITE}| {Colors.DIM}{build}{Colors.RESET}", end='')
    
    # Language selector and username on the right
    lang_flag = TRANSLATIONS[CURRENT_LANG]["flag"]
    lang_name = TRANSLATIONS[CURRENT_LANG]["name"]
    username = os.environ.get('USER', 'user')[:15]
    right_text = f"{lang_flag} {lang_name} | {username} {Colors.DIM}(esc-q){Colors.RESET}"
    
    # Calculate position for right-aligned text
    right_pos = cols - len(f"{lang_name} | {username} (esc-q)") - 5
    move_cursor(right_pos, 1)
    print(f"{Colors.BG_ORANGE}{Colors.WHITE}{right_text}{Colors.RESET}", end='')
    
    # Line 2: Navigation breadcrumb - ensure full width orange background
    # Already filled with orange in the loop above, but redraw to be safe
    move_cursor(1, 2)
    sys.stdout.write(f"{Colors.BG_ORANGE}{' ' * cols}{Colors.RESET}")
    sys.stdout.flush()
    
    # Draw breadcrumb if exists
    breadcrumb = get_navigation_breadcrumb()
    if breadcrumb:
        move_cursor(3, 2)  # Start breadcrumb with small indent
        # Use sys.stdout.write to ensure no line artifacts
        sys.stdout.write(f"{Colors.BG_ORANGE}{Colors.WHITE}  {breadcrumb}  {Colors.RESET}")
        sys.stdout.flush()


def update_sidebar_selection():
    """Update only the sidebar selection without redrawing everything"""
    try:
        cols, lines = get_terminal_size()
        
        # Safety checks
        if not hasattr(menu_state, 'modules') or not hasattr(menu_state, 'tools') or not hasattr(menu_state, 'dev_tools'):
            return
        if not menu_state.modules:
            return
        
        # Use stored tools position for consistency
        if not hasattr(menu_state, 'tools_start_y'):
            menu_state.tools_start_y = 6 + len(menu_state.modules) + 2
            
        # Clear any pending output and input buffer to prevent artifacts
        sys.stdout.flush()
        if TERMIOS_AVAILABLE:
            try:
                import termios
                termios.tcflush(sys.stdin, termios.TCIFLUSH)
                termios.tcflush(sys.stdin, termios.TCIOFLUSH)
            except:
                pass
        
        # Reset terminal attributes to ensure clean state
        print("\033[0m", end='', flush=True)  # Reset all attributes
        
        # Additional flush to ensure all output is written
        sys.stdout.flush()
        
        # Only update the two changed lines, not entire content
        if menu_state.current_section == 0:
            # Modules section
            y_pos = 6
            
            # Update previous selection
            if (menu_state.previous_index is not None and 
                0 <= menu_state.previous_index < len(menu_state.modules)):
                prev_y = y_pos + menu_state.previous_index
                if prev_y < lines - 1:  # Stop at footer
                    move_cursor(2, prev_y)
                    # Clear line completely first
                    print(f"\033[2K", end='', flush=True)  # Clear entire line
                    move_cursor(2, prev_y)
                    name = menu_state.modules[menu_state.previous_index][1]
                    print(f"{Colors.BG_GRAY}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}", end='', flush=True)
            
            # Update current selection
            if 0 <= menu_state.selected_index < len(menu_state.modules):
                curr_y = y_pos + menu_state.selected_index
                if curr_y < lines - 1:  # Stop at footer
                    move_cursor(2, curr_y)
                    # Clear line first
                    print(f"\033[2K", end='', flush=True)  # Clear entire line
                    move_cursor(2, curr_y)
                    name = menu_state.modules[menu_state.selected_index][1]
                    print(f"{Colors.BG_ORANGE}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}", end='', flush=True)
        elif menu_state.current_section == 1:
            # Tools section - use stored position
            y_pos = menu_state.tools_start_y + 2
        
            # Update previous selection
            if (menu_state.previous_index is not None and 
                0 <= menu_state.previous_index < len(menu_state.tools)):
                prev_y = y_pos + menu_state.previous_index
                if prev_y < lines - 1:  # Stop at footer
                    move_cursor(2, prev_y)
                    # Clear line completely first
                    print(f"\033[2K", end='', flush=True)  # Clear entire line
                    move_cursor(2, prev_y)
                    name = menu_state.tools[menu_state.previous_index][1]
                    print(f"{Colors.BG_GRAY}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}", end='', flush=True)
            
            # Update current selection
            if 0 <= menu_state.selected_index < len(menu_state.tools):
                curr_y = y_pos + menu_state.selected_index
                if curr_y < lines - 1:  # Stop at footer
                    move_cursor(2, curr_y)
                    # Clear line first
                    print(f"\033[2K", end='', flush=True)  # Clear entire line
                    move_cursor(2, curr_y)
                    name = menu_state.tools[menu_state.selected_index][1]
                    print(f"{Colors.BG_ORANGE}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}", end='', flush=True)
        else:
            # Dev tools section
            y_pos = menu_state.dev_tools_start_y + 2
        
            # Update previous selection
            if (menu_state.previous_index is not None and 
                0 <= menu_state.previous_index < len(menu_state.dev_tools)):
                prev_y = y_pos + menu_state.previous_index
                if prev_y < lines - 1:  # Stop at footer
                    move_cursor(2, prev_y)
                    # Clear line completely first
                    print(f"\033[2K", end='', flush=True)  # Clear entire line
                    move_cursor(2, prev_y)
                    name = menu_state.dev_tools[menu_state.previous_index][1]
                    print(f"{Colors.BG_GRAY}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}", end='', flush=True)
            
            # Update current selection
            if 0 <= menu_state.selected_index < len(menu_state.dev_tools):
                curr_y = y_pos + menu_state.selected_index
                if curr_y < lines - 1:  # Stop at footer
                    move_cursor(2, curr_y)
                    # Clear line first
                    print(f"\033[2K", end='', flush=True)  # Clear entire line
                    move_cursor(2, curr_y)
                    name = menu_state.dev_tools[menu_state.selected_index][1]
                    print(f"{Colors.BG_ORANGE}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}", end='', flush=True)
        
        # Ensure cursor is hidden
        hide_cursor()
        
        # Reset terminal attributes and final flush
        print("\033[0m", end='', flush=True)  # Reset all attributes
        sys.stdout.flush()
        
        # Update content area only
        draw_main_content()
    except Exception as e:
        # Log but don't crash
        debug_mode = os.environ.get('UNIBOS_DEBUG', '').lower() == 'true'
        if debug_mode:
            with open('/tmp/unibos_debug.log', 'a') as f:
                f.write(f"update_sidebar_selection error: {type(e).__name__}: {str(e)}\n")
                import traceback
                f.write(traceback.format_exc())
                f.write(f"State: section={menu_state.current_section}, index={menu_state.selected_index}, prev={menu_state.previous_index}\n")
                f.write(f"Modules: {len(menu_state.modules) if hasattr(menu_state, 'modules') else 'None'}\n")
                f.write(f"Tools: {len(menu_state.tools) if hasattr(menu_state, 'tools') else 'None'}\n")
                f.flush()

def draw_sidebar():
    """Draw left sidebar with modules"""
    cols, lines = get_terminal_size()
    sidebar_width = 25
    
    # Check if we should dim the sidebar (when in submenu)
    is_dimmed = menu_state.in_submenu is not None
    
    # CRITICAL: Clear entire sidebar area to remove ALL old highlights and artifacts
    # Start from line 3 (after header) and stop at footer
    for y in range(3, lines - 1):  # Stop at footer (lines-1)
        move_cursor(1, y)
        # Clear the entire line first
        sys.stdout.write('\033[2K')  # Clear entire line
        sys.stdout.flush()
        # Fill entire sidebar width with gray background
        move_cursor(1, y)
        sys.stdout.write(f"{Colors.BG_GRAY}{' ' * sidebar_width}{Colors.RESET}")
        sys.stdout.flush()
    
    # Determine if sidebar should be dimmed (when in submenu)
    is_dimmed = menu_state.in_submenu is not None
    text_color = Colors.DIM if is_dimmed else Colors.WHITE
    title_color = Colors.DIM if is_dimmed else Colors.ORANGE
    
    # Draw sidebar title
    move_cursor(2, 4)  # Line 4 for the title
    sys.stdout.write(f"{Colors.BG_GRAY}{Colors.BOLD}{title_color} modules{' ' * (sidebar_width - 9)}{Colors.RESET}")
    sys.stdout.flush()
    
    # Draw modules
    y_pos = 6  # Start position for modules
    for i, (key, name, desc, available, action) in enumerate(menu_state.modules):
        if y_pos < lines - 1:  # Stop at footer
            move_cursor(2, y_pos)
            # Clear line first to prevent artifacts
            sys.stdout.write('\033[2K')  # Clear entire line
            sys.stdout.flush()
            move_cursor(2, y_pos)
            
            # Only highlight if we're in modules section AND this is the selected index AND not in submenu
            if menu_state.current_section == 0 and i == menu_state.selected_index and not is_dimmed:
                sys.stdout.write(f"{Colors.BG_ORANGE}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}")
            else:
                sys.stdout.write(f"{Colors.BG_GRAY}{text_color} {name[:22]:<22} {Colors.RESET}")
            sys.stdout.flush()
            y_pos += 1
    
    # Store tools position for consistent rendering
    menu_state.tools_start_y = y_pos + 3  # Extra space between sections
    
    # Draw tools section at fixed position
    move_cursor(2, menu_state.tools_start_y)
    sys.stdout.write(f"{Colors.BG_GRAY}{Colors.BOLD}{title_color} tools{' ' * (sidebar_width - 7)}{Colors.RESET}")
    sys.stdout.flush()
    
    # Draw tools
    y_pos = menu_state.tools_start_y + 2
    for i, (key, name, desc, available, action) in enumerate(menu_state.tools):
        if y_pos < lines - 1:  # Stop at footer
            move_cursor(2, y_pos)
            # Clear line first to prevent artifacts
            sys.stdout.write('\033[2K')  # Clear entire line
            sys.stdout.flush()
            move_cursor(2, y_pos)
            
            # Only highlight if we're in tools section AND this is the selected index AND not in submenu
            if menu_state.current_section == 1 and i == menu_state.selected_index and not is_dimmed:
                sys.stdout.write(f"{Colors.BG_ORANGE}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}")
            else:
                sys.stdout.write(f"{Colors.BG_GRAY}{text_color} {name[:22]:<22} {Colors.RESET}")
            sys.stdout.flush()
            y_pos += 1
    
    # Store dev tools position
    menu_state.dev_tools_start_y = y_pos + 3  # Extra space between sections
    
    # Draw dev tools section
    move_cursor(2, menu_state.dev_tools_start_y)
    sys.stdout.write(f"{Colors.BG_GRAY}{Colors.BOLD}{title_color} dev tools{' ' * (sidebar_width - 11)}{Colors.RESET}")
    sys.stdout.flush()
    
    # Draw dev tools
    y_pos = menu_state.dev_tools_start_y + 2
    for i, (key, name, desc, available, action) in enumerate(menu_state.dev_tools):
        if y_pos < lines - 1:  # Stop at footer
            move_cursor(2, y_pos)
            # Clear line first to prevent artifacts
            sys.stdout.write('\033[2K')  # Clear entire line
            sys.stdout.flush()
            move_cursor(2, y_pos)
            
            # Only highlight if we're in dev tools section AND this is the selected index AND not in submenu
            if menu_state.current_section == 2 and i == menu_state.selected_index and not is_dimmed:
                sys.stdout.write(f"{Colors.BG_ORANGE}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}")
            else:
                sys.stdout.write(f"{Colors.BG_GRAY}{text_color} {name[:22]:<22} {Colors.RESET}")
            sys.stdout.flush()
            y_pos += 1
    
    # Fill remaining sidebar area with gray background to prevent artifacts
    # This ensures the entire sidebar column is consistently gray
    while y_pos < lines - 1:  # Fill until footer
        move_cursor(1, y_pos)
        sys.stdout.write('\033[2K')  # Clear entire line
        move_cursor(1, y_pos)
        sys.stdout.write(f"{Colors.BG_GRAY}{' ' * sidebar_width}{Colors.RESET}")
        y_pos += 1
    
    # Ensure cursor is hidden
    hide_cursor()
    
    # Final flush to ensure all sidebar updates are written
    sys.stdout.flush()

def draw_footer(only_time=False):
    """Draw footer with navigation hints, live clock and online status LED"""
    cols, lines = get_terminal_size()
    
    # Footer takes exactly 1 line
    footer_start = lines - 1
    
    # If only updating time, skip full clear
    if not only_time:
        # Clear footer area (exactly 1 line)
        move_cursor(1, footer_start)
        print(f"{Colors.BG_DARK}{' ' * cols}{Colors.RESET}", end='', flush=True)
    
    # Navigation hints on footer line
    if not only_time:
        move_cursor(2, footer_start)  # Single line footer
        # Context-specific navigation hints
        if menu_state.in_submenu in ['system_info', 'security_tools']:
            nav_text = "‚Üê back/esc to return | enter to close"
        elif menu_state.in_submenu == 'tools':
            nav_text = "‚Üë‚Üì navigate | ‚Üí select | ‚Üê back"
        elif menu_state.in_submenu:
            nav_text = "‚Üê back/esc to return"
        else:
            nav_text = "‚Üë‚Üì navigate | tab switch | ‚Üí enter | ‚Üê back | l language | d database"
        print(f"{Colors.BG_DARK}{Colors.DIM}{nav_text}{Colors.RESET}", end='', flush=True)
    
    # Get current date and time - FORCED Istanbul/Europe timezone
    if ZoneInfo:
        try:
            istanbul_tz = ZoneInfo("Europe/Istanbul")
            now = datetime.now(istanbul_tz)
        except:
            # Fallback: use local time (system should be in Istanbul timezone)
            now = datetime.now()
    else:
        # No zoneinfo available, use local time
        now = datetime.now()
    
    current_time = now.strftime("%H:%M:%S")
    current_date = now.strftime("%d.%m.%Y")  # Turkish format
    
    # Calculate positions for date, time and status
    status_text = "online"
    status = get_system_status()
    
    # Calculate widths
    date_width = len(current_date)
    time_width = len(current_time)
    status_width = len(status_text) + 2  # "online" + space + LED
    
    # Position date, time and status together at the right
    date_pos = cols - status_width - time_width - date_width - 6  # 6 for spacing
    time_pos = cols - status_width - time_width - 3  # 3 for spacing
    status_pos = cols - status_width - 2  # 2 for edge padding
    
    # Draw date
    if not only_time:
        move_cursor(date_pos, footer_start)  # Single line footer
        print(f"{Colors.BG_DARK}{Colors.WHITE}{current_date}{Colors.RESET}", end='')
    
    # Draw time - always update
    move_cursor(time_pos, footer_start)  # Single line footer
    print(f"{Colors.BG_DARK}{Colors.CYAN}{current_time}{Colors.RESET}", end='', flush=True)
    
    # Draw online status LED
    if not only_time:
        move_cursor(status_pos, footer_start)  # Single line footer
        print(f"{Colors.BG_DARK}{Colors.WHITE}online {status}{Colors.RESET}", end='', flush=True)

def initialize_menu_items():
    """Initialize menu items for sidebar"""
    # Module items with translation support
    menu_state.modules = [
        ("recaria", f"ü™ê {t('recaria')}", t('universe_explorer'), True, lambda: handle_module_launch('recaria')),
        ("birlikteyiz", f"üì° {t('birlikteyiz')}", t('mesh_network'), True, lambda: handle_module_launch('birlikteyiz')),
        ("kisisel", f"üìà {t('kisisel')}", t('inflation_calc'), True, lambda: handle_module_launch('kisisel')),
        ("currencies", f"üí∞ {t('currencies')}", t('exchange_rates'), True, lambda: handle_module_launch('currencies')),
    ]
    
    # Tool items with translation support
    menu_state.tools = [
        ("system_scrolls", f"üìä system scrolls", "forge status & info", True, lambda: handle_tool_launch('system_scrolls')),
        ("castle_guard", f"üîí castle guard", "fortress security", True, lambda: handle_tool_launch('castle_guard')),
        ("forge_smithy", f"üîß forge smithy", "setup forge tools", True, lambda: handle_tool_launch('forge_smithy')),
        ("anvil_repair", f"üõ†Ô∏è  anvil repair", "mend & fix issues", True, lambda: handle_tool_launch('anvil_repair')),
        ("code_forge", f"üì¶ code forge", "version chronicles", True, show_git_menu),
        ("web_forge", f"üåê web forge", "web portal gateway", True, lambda: handle_tool_launch('web_forge')),
    ]
    
    # Dev tools - new section
    menu_state.dev_tools = [
        ("ai_builder", f"ü§ñ ai builder", "ai-powered development", True, ai_builder_tools),
        ("database_setup", "üóÑÔ∏è  database setup", "postgresql installer", True, database_setup_wizard),
        ("web_forge", "üåê web forge", "django & react servers", True, web_forge_menu),
        ("sd_card", f"üíæ {t('sd_card')}", t('sd_operations'), True, None),
    ]

def draw_main_content():
    """Draw main content area without right panel"""
    cols, lines = get_terminal_size()
    content_x = 27  # After sidebar
    
    # Use full width for content area (no right panel)
    content_width = cols - content_x - 1  # Only 1 for minimal right margin
    
    # Calculate content height with proper boundaries
    content_height = lines - 4  # Use full height: 2 for header, 1 for footer, 1 for bottom margin
    
    # Clear any artifacts between sidebar and content first
    for y in range(3, lines - 1):  # Start from line 3 (after header) and stop at footer
        move_cursor(25, y)  # Position between sidebar and content
        print("  ", end='', flush=True)
    
    # Clear main content area with lighter background
    # Respect header (lines 1-2) and footer (lines-2 to lines) boundaries
    for y in range(3, lines - 1):  # Start from 3 (after header) and stop at footer
        move_cursor(content_x, y)
        # Make sure we don't clear beyond terminal width
        clear_width = min(content_width, cols - content_x)
        if clear_width > 0:
            print(' ' * clear_width, end='', flush=True)
    
    if menu_state.in_submenu == 'tools':
        draw_tools_menu(content_x, content_width, content_height)
    elif menu_state.in_submenu == 'system_info':
        draw_system_info_screen(content_x, content_width, content_height)
    elif menu_state.in_submenu == 'security_tools':
        draw_security_tools_screen(content_x, content_width, content_height)
    elif menu_state.in_submenu == 'git_manager':
        # Git manager is handling its own UI, just clear content area
        pass
    elif menu_state.in_submenu == 'web_forge':
        # Web forge menu is handling its own drawing
        pass
    else:
        # Draw selected module info
        if menu_state.current_section == 0:
            if menu_state.selected_index < len(menu_state.modules):
                key, name, desc, available, action = menu_state.modules[menu_state.selected_index]
                draw_module_info(content_x, content_width, content_height, key, name, desc)
        elif menu_state.current_section == 1:
            if menu_state.selected_index < len(menu_state.tools):
                key, name, desc, available, action = menu_state.tools[menu_state.selected_index]
                draw_module_info(content_x, content_width, content_height, key, name, desc)
        else:  # dev tools section
            if menu_state.selected_index < len(menu_state.dev_tools):
                key, name, desc, available, action = menu_state.dev_tools[menu_state.selected_index]
                draw_module_info(content_x, content_width, content_height, key, name, desc)
    
    # No right panel anymore


def show_server_action(title, color, show_back_hint=True):
    """Show server action in main content area"""
    cols, lines = get_terminal_size()
    content_x = 27  # Match main content area
    
    # Use full width for content area
    content_width = cols - content_x - 1  # Only 1 for minimal right margin
    
    # Clear the main content area (without background color)
    for y in range(3, lines - 1):
        move_cursor(content_x, y)
        print(' ' * content_width, end='', flush=True)
    
    # Draw content box with back navigation hint in title if requested
    if show_back_hint:
        title_with_nav = f"{title}  {Colors.DIM}(‚Üê Back){Colors.RESET}"
        draw_box(content_x, 3, content_width - 1, lines - 4, title_with_nav, color)
    else:
        draw_box(content_x, 3, content_width - 1, lines - 4, title, color)


def draw_module_info(x, width, height, key, name, desc):
    """Draw module information in main content area"""
    # Use the full content width
    box_width = width - 1  # Minimal margin for maximum space
    box_height = height  # Use full height
    draw_box(x, 3, box_width, box_height, name, Colors.CYAN)  # Start at line 3 (immediately after header)
    
    # Module description
    move_cursor(x + 3, 5)
    print(f"{Colors.BOLD}description:{Colors.RESET} {desc}")
    
    # Module status
    move_cursor(x + 3, 7)
    status = "ready" if key in ['recaria', 'currencies', 'birlikteyiz', 'kisisel', 'ai_builder', 'system_info', 'security_tools', 'git', 'web_forge'] else "coming soon"
    color = Colors.GREEN if status == "ready" else Colors.YELLOW
    print(f"{Colors.BOLD}status:{Colors.RESET} {color}{status}{Colors.RESET}")
    
    # Module-specific information
    y_pos = 10
    if key == 'recaria':
        stats = [
            ("consciousness", "1 / 8,000,000,000"),
            ("collective mind", "‚àû past + present + future"),
            ("", ""),
            ("philosophy", "we are part of the whole"),
            ("", "consciousness = lived experiences"),
            ("", "              + present influence"),
            ("", "              + future potential"),
            ("", ""),
            ("next 2 years", "‚Ä¢ ai-human fusion (1000x)"),
            ("", "‚Ä¢ quantum communication"),
            ("", "‚Ä¢ metaverse migration"),
            ("", "‚Ä¢ neuro-link awakening"),
            ("", "‚Ä¢ global crisis sync"),
            ("", ""),
            ("game features", "‚Ä¢ explore infinite universe"),
            ("", "‚Ä¢ shape collective reality"),
        ]
    elif key == 'birlikteyiz':
        stats = [
            ("network type", "lora mesh"),
            ("range", "15km (open area)"),
            ("encryption", "aes-256"),
            ("nodes active", "42"),
            ("", ""),
            ("use cases", "‚Ä¢ emergency communication"),
            ("", "‚Ä¢ earthquake response"),
            ("", "‚Ä¢ off-grid messaging"),
        ]
    elif key == 'currencies':
        stats = [
            ("data source", "tcmb + coingecko"),
            ("update interval", "real-time"),
            ("currencies", "150+ supported"),
            ("crypto", "top 100 coins"),
            ("", ""),
            ("features", "‚Ä¢ portfolio tracking"),
            ("", "‚Ä¢ price alerts"),
            ("", "‚Ä¢ historical charts"),
        ]
    elif key == 'kisisel':
        stats = [
            ("calculation method", "personal basket"),
            ("categories", "customizable"),
            ("data privacy", "100% local"),
            ("accuracy", "¬±0.5%"),
            ("", ""),
            ("features", "‚Ä¢ product tracking"),
            ("", "‚Ä¢ trend analysis"),
            ("", "‚Ä¢ savings tips"),
        ]
    elif key == 'ai_builder':
        stats = [
            ("ai model", "claude 3.5"),
            ("capabilities", "intelligent development"),
            ("features", "developments & agents"),
            ("", ""),
            ("features", "‚Ä¢ chat mode"),
            ("", "‚Ä¢ code development"),
            ("", "‚Ä¢ bug analysis"),
            ("", "‚Ä¢ feature brainstorming"),
            ("", "‚Ä¢ code review"),
            ("", "‚Ä¢ documentation helper"),
        ]
    elif key == 'web_backend':
        stats = [
            ("framework", "django 5.0+"),
            ("database", "postgresql"),
            ("auth", "jwt + 2fa"),
            ("api", "rest framework"),
            ("", ""),
            ("features", "‚Ä¢ secure authentication"),
            ("", "‚Ä¢ scalable architecture"),
            ("", "‚Ä¢ real-time websockets"),
            ("", "‚Ä¢ celery background tasks"),
            ("", "‚Ä¢ redis caching"),
        ]
    elif key == 'web_frontend':
        stats = [
            ("framework", "react 18"),
            ("state", "redux toolkit"),
            ("ui theme", "ultima online"),
            ("styling", "styled-components"),
            ("", ""),
            ("features", "‚Ä¢ responsive design"),
            ("", "‚Ä¢ real-time updates"),
            ("", "‚Ä¢ dark mode"),
            ("", "‚Ä¢ pwa ready"),
            ("", "‚Ä¢ chart.js graphs"),
        ]
    elif key == 'web_forge':
        stats = [
            ("backend", "django + postgresql"),
            ("frontend", "react + redux"),
            ("ports", "8000 (api) / 3000 (ui)"),
            ("", ""),
            ("servers", "‚Ä¢ django backend"),
            ("", "‚Ä¢ react frontend"),
            ("", "‚Ä¢ both servers"),
            ("", ""),
            ("features", "‚Ä¢ auto setup"),
            ("", "‚Ä¢ manual mode"),
        ]
    else:
        stats = []
    
    # Display stats
    for label, value in stats:
        if y_pos < height - 3:
            move_cursor(x + 3, y_pos)
            if label:
                if label in ["features", "use cases", "philosophy", "next 2 years", "game features"]:
                    print(f"{Colors.BOLD}{Colors.CYAN}{label}:{Colors.RESET}")
                elif label == "consciousness":
                    print(f"{Colors.BOLD}{label}:{Colors.RESET} {Colors.YELLOW}{value}{Colors.RESET}")
                elif label == "collective mind":
                    print(f"{Colors.BOLD}{label}:{Colors.RESET} {Colors.MAGENTA}{value}{Colors.RESET}")
                else:
                    print(f"{Colors.DIM}{label}:{Colors.RESET} {value}")
            else:
                print(f"{value}")
            y_pos += 1
    
    # Launch hint (only show if not already in a submenu)
    if status == "ready" and not menu_state.in_submenu:
        move_cursor(x + 3, height - 3)
        print(f"{Colors.DIM}press enter to launch{Colors.RESET}")

def draw_tools_menu(x, width, height):
    """Draw tools submenu"""
    draw_box(x, 3, width - 1, height, "üõ†Ô∏è tools", Colors.GREEN)
    
    # Initialize tool items if not done
    if not menu_state.tool_items:
        menu_state.tool_items = [
            ("system_info", "üìä system information", "view system details"),
            ("security_tools", "üîí security tools", "security utilities"),
            ("setup_manager", "üîß setup manager", "initial setup"),
            ("repair_tools", "üõ†Ô∏è repair tools", "fix issues"),
            ("git", "üì¶ git manager", "version control"),
            ("web_interface", "üåê web interface", "browser ui"),
        ]
    
    # Display tool items (adjusted for box starting at line 3)
    y_pos = 5
    for i, (key, name, desc) in enumerate(menu_state.tool_items):
        if y_pos + 2 < height:
            move_cursor(x + 3, y_pos)
            
            # Highlight selected item
            if i == menu_state.tool_selected_index:
                print(f"{Colors.BG_BLUE}{Colors.WHITE} {name:<35} {Colors.RESET}")
            else:
                print(f"  {name}")
            
            move_cursor(x + 5, y_pos + 1)
            print(f"{Colors.DIM}{desc}{Colors.RESET}")
            y_pos += 2
    
    # Instructions
    move_cursor(x + 3, height - 2)
    print(f"{Colors.DIM}‚Üë‚Üì navigate | enter select | esc back{Colors.RESET}")

def draw_system_info_screen(x, width, height):
    """Draw system information screen"""
    draw_box(x, 3, width - 1, height, "üìä system information", Colors.BLUE)
    
    # Get system information
    info = get_system_info()
    
    # Display information (adjusted for box starting at line 3)
    y_pos = 5
    move_cursor(x + 3, y_pos)
    print(f"{Colors.BOLD}system information:{Colors.RESET}")
    y_pos += 2
    
    # System details
    details = [
        ("hostname", info.get("hostname", "unknown")),
        ("platform", info.get("platform", "unknown")),
        ("architecture", info.get("architecture", "unknown")),
        ("python", info.get("python_version", "unknown")),
        ("", ""),  # Spacer
        ("cpu cores", info.get("cpu_cores", "n/a")),
        ("cpu usage", info.get("cpu_usage", "n/a")),
        ("", ""),  # Spacer
        ("memory total", info.get("memory_total", "n/a")),
        ("memory used", info.get("memory_used", "n/a")),
        ("", ""),  # Spacer
        ("disk total", info.get("disk_total", "n/a")),
        ("disk free", info.get("disk_free", "n/a")),
    ]
    
    for label, value in details:
        if y_pos < height - 2:
            move_cursor(x + 3, y_pos)
            if label:
                print(f"{Colors.DIM}{label}:{Colors.RESET} {value}")
            y_pos += 1
    
    # Press any key hint
    move_cursor(x + 3, height - 2)
    print(f"{Colors.DIM}press any key to return{Colors.RESET}")

def draw_security_tools_screen(x, width, height):
    """Draw security tools screen"""
    draw_box(x, 3, width - 1, height, "üîí security tools", Colors.RED)
    
    # Security information (adjusted for box starting at line 3)
    y_pos = 5
    move_cursor(x + 3, y_pos)
    print(f"{Colors.BOLD}network security:{Colors.RESET}")
    y_pos += 2
    
    if NETWORK_UTILS_AVAILABLE:
        security_info = get_network_security_info()
        
        # Display security details
        details = [
            ("firewall status", security_info.get("firewall_status", "unknown")),
            ("open ports", str(security_info.get("open_ports", []))),
            ("active connections", str(security_info.get("active_connections", 0))),
            ("", ""),  # Spacer
            ("security level", security_info.get("security_level", "unknown")),
        ]
        
        for label, value in details:
            if y_pos < height - 2:
                move_cursor(x + 3, y_pos)
                if label:
                    print(f"{Colors.DIM}{label}:{Colors.RESET} {value}")
                y_pos += 1
    else:
        move_cursor(x + 3, y_pos)
        print(f"{Colors.YELLOW}security monitoring not available{Colors.RESET}")
        y_pos += 2
        move_cursor(x + 3, y_pos)
        print(f"{Colors.DIM}network_utils module required{Colors.RESET}")
    
    # Press any key hint
    move_cursor(x + 3, height - 2)
    print(f"{Colors.DIM}press any key to return{Colors.RESET}")

def draw_main_screen():
    """Draw the complete main screen"""
    clear_screen()
    hide_cursor()
    
    # Initialize menu items if needed
    if not menu_state.modules:
        initialize_menu_items()
    
    # Ensure terminal is fully cleared before drawing
    sys.stdout.write('\033[2J\033[H')  # Clear screen and move to home
    sys.stdout.write('\033[?25l')  # Hide cursor during drawing
    sys.stdout.flush()
    
    # Draw UI components in correct order
    draw_header()  # Draws lines 1-3 with orange background
    
    # Ensure no gap between header and content areas
    # Clear line 4 specifically to prevent any gray band
    cols, _ = get_terminal_size()
    move_cursor(1, 4)
    print(f"\033[2K", end='')  # Clear entire line
    
    draw_sidebar()  # Draws from line 4 onwards
    draw_footer()   # Draws at bottom
    draw_main_content()  # Draws from line 4 onwards
    
    # Show language selection if active
    if menu_state.in_language_menu:
        show_language_selection()

def get_simple_key():
    """Simple key input without timeout - for splash screen and basic input"""
    try:
        if platform.system() == 'Windows':
            import msvcrt
            key = msvcrt.getch()
            if isinstance(key, bytes):
                key = key.decode('utf-8', errors='ignore')
            return key.lower() if key else ''
        else:
            if not TERMIOS_AVAILABLE:
                # Fallback for systems without termios
                ch = input()
                return ch[0].lower() if ch else ''
            
            import termios
            import tty
            fd = sys.stdin.fileno()
            old_settings = termios.tcgetattr(fd)
            try:
                tty.setraw(sys.stdin.fileno())
                key = sys.stdin.read(1)
                return key.lower() if key else ''
            finally:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    except Exception:
        return ''

def get_single_key(timeout=0.1):
    """Get single character input with arrow key support - fixed implementation"""
    debug = os.environ.get('UNIBOS_DEBUG', '').lower() == 'true'
    try:
        if platform.system() == 'Windows':
            import msvcrt
            if msvcrt.kbhit():
                msvcrt.getch()
            key = msvcrt.getch()
            if key == b'\xe0':  # Special key prefix on Windows
                key = msvcrt.getch()
                if key == b'H':
                    return '\x1b[A'  # Up
                elif key == b'P':
                    return '\x1b[B'  # Down
                elif key == b'K':
                    return '\x1b[D'  # Left
                elif key == b'M':
                    return '\x1b[C'  # Right
            elif key == b'\r':
                return '\r'
            elif key == b'\x1b':
                return '\x1b'
            elif key == b'\t':
                return '\t'
            elif isinstance(key, bytes):
                key = key.decode('utf-8', errors='ignore')
            return key
        else:
            # Unix-like systems
            if not TERMIOS_AVAILABLE:
                # Fallback for systems without termios
                ch = input("Enter command (q=quit): ")
                if ch: 
                    return ch[0].lower()
                return '\r'
                
            import termios
            import tty
            import select
            fd = sys.stdin.fileno()
            old_settings = termios.tcgetattr(fd)
            
            try:
                tty.setraw(sys.stdin.fileno())
                
                # Use select with reasonable timeout
                rlist, _, _ = select.select([sys.stdin], [], [], timeout)
                if rlist:
                    ch = sys.stdin.read(1)
                    if debug:
                        with open('/tmp/unibos_key_debug.log', 'a') as f:
                            f.write(f"Read char: {repr(ch)}\n")
                else:
                    return None  # Timeout, no key pressed
                
                # Handle escape sequences - WORKING VERSION FROM v130/v186
                if ch == '\x1b':  # ESC
                    try:
                        # Direct reads without select - THIS WORKS!
                        ch2 = sys.stdin.read(1)
                        if ch2 == '[':
                            ch3 = sys.stdin.read(1)
                            if ch3 == 'A':
                                return '\x1b[A'  # Up
                            elif ch3 == 'B':
                                return '\x1b[B'  # Down
                            elif ch3 == 'C':
                                return '\x1b[C'  # Right
                            elif ch3 == 'D':
                                return '\x1b[D'  # Left
                            # Handle numeric escape sequences (e.g., ESC[1A)
                            elif ch3.isdigit():
                                ch4 = sys.stdin.read(1)
                                if ch4 == 'A':
                                    return '\x1b[A'  # Up
                                elif ch4 == 'B':
                                    return '\x1b[B'  # Down
                                elif ch4 == 'C':
                                    return '\x1b[C'  # Right
                                elif ch4 == 'D':
                                    return '\x1b[D'  # Left
                    except:
                        pass
                    return '\x1b'  # Just ESC
                elif ch == '\r':
                    return '\r'
                elif ch == '\t':
                    return '\t'
                return ch
                
            finally:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
                        
    except Exception as e:
        if debug:
            with open('/tmp/unibos_key_debug.log', 'a') as f:
                f.write(f"Exception in get_single_key: {e}\n")
        return None

def show_language_selection():
    """Show language selection overlay with arrow key navigation"""
    cols, lines = get_terminal_size()
    
    # Language menu dimensions
    lang_width = 40
    lang_height = 15
    lang_x = (cols - lang_width) // 2
    lang_y = (lines - lang_height) // 2
    
    # First clear the language box area with dark background
    for y in range(lang_y, lang_y + lang_height):
        move_cursor(lang_x, y)
        print(f"{Colors.BG_DARK}{' ' * lang_width}{Colors.RESET}", end='')
    
    # Draw language selection box
    draw_box(lang_x, lang_y, lang_width, lang_height, 
             f"{t('select_language')}", Colors.YELLOW)
    
    # Get available languages
    languages = get_available_languages()
    
    # Display languages with selection highlight
    for i, (code, name, flag) in enumerate(languages[:10]):  # Show max 10
        y_pos = lang_y + 2 + i
        
        if i == menu_state.language_selected_index:
            # Selected item with arrow - limit to box width
            move_cursor(lang_x + 3, y_pos)
            # First clear the line within box boundaries
            print(f"{' ' * (lang_width - 6)}", end='')
            move_cursor(lang_x + 3, y_pos)
            # Now print with blue background, strictly limited
            display_text = f" ‚ñ∂ {flag} {name}"
            max_width = lang_width - 6
            if len(display_text) > max_width:
                display_text = display_text[:max_width]
            # Print blue background only for the text length
            print(f"{Colors.BG_BLUE}{Colors.WHITE}{display_text}{Colors.RESET}", end='')
            # Fill remaining space without background
            remaining = max_width - len(display_text)
            if remaining > 0:
                print(f"{' ' * remaining}", end='')
            print()  # End line
        elif code == CURRENT_LANG:
            # Current language highlighted
            move_cursor(lang_x + 3, y_pos)
            display_text = f"   {flag} {name}"
            max_width = lang_width - 10  # Leave space for checkmark
            if len(display_text) > max_width:
                display_text = display_text[:max_width]
            print(f"{Colors.YELLOW}{display_text}{Colors.RESET}", end='')
            # Position checkmark at fixed location
            move_cursor(lang_x + lang_width - 9, y_pos)
            print(f"{Colors.YELLOW}‚úì{Colors.RESET}")
        else:
            # Regular items
            move_cursor(lang_x + 3, y_pos)
            display_text = f"   {flag} {name}"
            max_width = lang_width - 6
            if len(display_text) > max_width:
                display_text = display_text[:max_width]
            print(f"{display_text}")
    
    # Instructions
    move_cursor(lang_x + 3, lang_y + lang_height - 2)
    print(f"{Colors.DIM}‚Üë‚Üì navigate | enter select | l close{Colors.RESET}")

def handle_menu_selection():
    """Handle menu item selection"""
    if menu_state.current_section == 0:  # Modules
        if menu_state.selected_index < len(menu_state.modules):
            key, name, desc, available, action = menu_state.modules[menu_state.selected_index]
            handle_module_launch(key)
    else:  # Tools
        if menu_state.selected_index < len(menu_state.tools):
            handle_tool_selection()

def show_recaria_submenu():
    """Show recaria submenu with game, vehicles, launch points, and starship calc"""
    menu_state.in_submenu = 'recaria'
    recaria_selected = 0
    
    recaria_items = [
        ("play", f"üéÆ {t('play_game')}", t('start_recaria')),
        ("vehicles", f"üöó {t('vehicles')}", t('transport')),
        ("launch_points", f"üöÄ {t('launch_points')}", t('eight_point_nav')),
        ("starship_calc", f"üõ∏ {t('starship_calc')}", t('spacex')),
    ]
    
    while True:
        draw_main_screen()
        
        # Draw recaria submenu in content area
        cols, lines = get_terminal_size()
        content_x = 27
        content_width = cols - content_x
        content_height = lines - 3
        
        # Clear content area
        for y in range(3, lines - 1):  # Stop before footer
            move_cursor(content_x, y)
            clear_width = min(content_width, cols - content_x)
            if clear_width > 0:
                print(' ' * clear_width, end='')
        
        # Draw box starting at line 3 (immediately after header)
        # Box extends to full width and down to footer
        draw_box(content_x, 3, content_width - 1, lines - 4, "ü™ê recaria", Colors.CYAN)
        
        # Display menu items (moved up by 1 since box starts at line 4 now)
        y_pos = 6
        for i, (key, name, desc) in enumerate(recaria_items):
            move_cursor(content_x + 3, y_pos)
            
            if i == recaria_selected:
                print(f"{Colors.BG_BLUE}{Colors.WHITE} {name:<40} {Colors.RESET}")
            else:
                print(f" {name:<40} ")
            
            move_cursor(content_x + 5, y_pos + 1)
            print(f"{Colors.DIM}{desc}{Colors.RESET}")
            y_pos += 3
        
        # Instructions
        move_cursor(content_x + 3, content_height - 2)
        print(f"{Colors.DIM}‚Üë‚Üì navigate | enter select | esc back{Colors.RESET}")
        
        # Get input
        key = get_single_key()
        
        if key == '\x1b[A' or key == 'k':  # Up
            recaria_selected = max(0, recaria_selected - 1)
        elif key == '\x1b[B' or key == 'j':  # Down
            recaria_selected = min(len(recaria_items) - 1, recaria_selected + 1)
        elif key == '\r' or key == '\x1b[C':  # Enter/Right
            selected_key = recaria_items[recaria_selected][0]
            if selected_key == 'play':
                clear_screen()
                print(f"{Colors.CYAN}{'='*50}{Colors.RESET}")
                print(f"{Colors.BOLD}üöÄ launching recaria...{Colors.RESET}")
                print(f"{Colors.CYAN}{'='*50}{Colors.RESET}\n")
                print(f"ü™ê {t('recaria')} - universe explorer")
                print(f"{Colors.GREEN}module loading...{Colors.RESET}")
                try:
                    sys.path.append(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'projects'))
                    from recaria.main import main as recaria_main
                    recaria_main()
                except ImportError:
                    print(f"{Colors.YELLOW}recaria module not found. please check installation.{Colors.RESET}")
                print(f"\n{Colors.DIM}press enter to continue...{Colors.RESET}")
                input()
            else:
                # Show coming soon for other options
                move_cursor(content_x + 10, content_height // 2)
                print(f"{Colors.YELLOW}feature coming soon!{Colors.RESET}")
                time.sleep(1)
        elif key == '\x1b' or key == '\x1b[D' or key == 'q':  # Esc/Left/q
            menu_state.in_submenu = None
            break

def run_claude_embedded(x_start, y_start, width):
    """Run Claude in embedded mode within the content area"""
    import pty
    import select
    import termios
    import tty
    
    # Save current terminal settings
    old_settings = termios.tcgetattr(sys.stdin)
    
    try:
        # Create pseudo-terminal
        master_fd, slave_fd = pty.openpty()
        
        # Fork process to run claude
        pid = os.fork()
        
        if pid == 0:  # Child process
            # Close master side
            os.close(master_fd)
            
            # Make slave side our stdin/stdout/stderr
            os.dup2(slave_fd, 0)
            os.dup2(slave_fd, 1)
            os.dup2(slave_fd, 2)
            
            # Close original slave fd
            if slave_fd > 2:
                os.close(slave_fd)
            
            # Set terminal size to match content area
            cols, lines = get_terminal_size()
            content_height = lines - 8  # Account for header/footer
            
            # Create a temporary directory for Claude to avoid loading large CLAUDE files
            import tempfile
            temp_dir = tempfile.mkdtemp(prefix='claude_session_')
            os.chdir(temp_dir)
            
            # Execute the system's claude command directly
            # This will use the existing authenticated session
            os.execvp('claude', ['claude'])
            
        else:  # Parent process
            # Close slave side
            os.close(slave_fd)
            
            # Set stdin to raw mode for direct input
            tty.setraw(sys.stdin.fileno())
            
            # Track cursor position within content area
            current_line = 0
            
            while True:
                # Check for input/output
                rlist, _, _ = select.select([sys.stdin, master_fd], [], [], 0.1)
                
                if sys.stdin in rlist:
                    # Read user input
                    data = os.read(sys.stdin.fileno(), 1024)
                    
                    # Check for ESC key to exit
                    if data == b'\x1b':
                        break
                    
                    # Send to claude
                    os.write(master_fd, data)
                
                if master_fd in rlist:
                    # Read claude output
                    try:
                        data = os.read(master_fd, 1024)
                        if not data:
                            break
                        
                        # Process and display output within content area
                        output = data.decode('utf-8', errors='replace')
                        
                        # Parse output and constrain to content area
                        # Get terminal size for bounds checking
                        cols, term_lines = get_terminal_size()
                        max_content_lines = term_lines - 8
                        
                        for char in output:
                            if char == '\n':
                                current_line += 1
                                if current_line >= max_content_lines:
                                    # Scroll content up
                                    current_line = max_content_lines - 1
                                move_cursor(x_start, y_start + current_line)
                                print(' ' * width, end='')
                                move_cursor(x_start, y_start + current_line)
                            elif char == '\r':
                                move_cursor(x_start, y_start + current_line)
                            else:
                                # Print character with content background
                                print(char, end='', flush=True)
                    except OSError:
                        break
            
            # Wait for child process
            os.waitpid(pid, 0)
            
    finally:
        # Restore terminal settings
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
        
        # Return to original directory
        os.chdir(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        
        # Clear and redraw UI
        draw_main_screen()

def run_database_setup_wizard():
    """Run database setup wizard in content area"""
    clear_screen()
    show_cursor()
    
    try:
        from database_setup_wizard import run_setup_wizard
        
        # Terminal ayarlarƒ±nƒ± kaydet ve normal moda al
        if TERMIOS_AVAILABLE:
            import termios
            fd = sys.stdin.fileno()
            old_settings = termios.tcgetattr(fd)
            # Normal terminal moduna ge√ß (raw mode'dan √ßƒ±k)
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        
        # Wizard'ƒ± √ßalƒ±≈ütƒ±r
        result = run_setup_wizard()
        
        # Ana ekrana d√∂n
        menu_state.in_submenu = None
        hide_cursor()
        draw_main_screen()
        
    except ImportError:
        print(f"{Colors.RED}Database setup wizard not found!{Colors.RESET}")
        time.sleep(2)
        menu_state.in_submenu = None
        hide_cursor()
        draw_main_screen()
    except Exception as e:
        print(f"{Colors.RED}Error running database setup: {e}{Colors.RESET}")
        time.sleep(3)
        menu_state.in_submenu = None
        hide_cursor()
        draw_main_screen()

def run_claude_in_content_area():
    """Run Claude CLI integrated in the content area with model selection"""
    # Get terminal dimensions
    cols, lines = get_terminal_size()
    content_x = 27  # Match main content area positioning
    content_width = max(20, cols - content_x)  # Ensure minimum width
    
    # Clear content area but keep UI frame
    for y in range(3, lines - 1):  # Better bottom margin
        move_cursor(content_x, y)
        print(' ' * content_width, end='', flush=True)
    
    # Draw Claude interface header with style matching Claude Code
    header_y = 3
    move_cursor(content_x + 2, header_y)
    print(f"{Colors.ORANGE}‚ï≠{'‚îÄ' * (content_width - 6)}‚ïÆ{Colors.RESET}")
    move_cursor(content_x + 2, header_y + 1)
    print(f"{Colors.ORANGE}‚îÇ{Colors.RESET} {Colors.BOLD}* welcome to claude code!{Colors.RESET}{''.ljust(content_width - 31)}{Colors.ORANGE}‚îÇ{Colors.RESET}")
    move_cursor(content_x + 2, header_y + 2)
    print(f"{Colors.ORANGE}‚ï∞{'‚îÄ' * (content_width - 6)}‚ïØ{Colors.RESET}")
    
    # Show model selection
    info_y = header_y + 4
    move_cursor(content_x + 4, info_y)
    print(f"{Colors.CYAN}select claude model:{Colors.RESET}")
    
    # Model options
    models = [
        ("default", "claude-3-haiku (fast, efficient)"),
        ("opus", "claude-3-opus (most capable)"),
        ("sonnet", "claude-3-sonnet (balanced)")
    ]
    
    selected_model = 0
    
    def draw_model_options():
        for i, (model, desc) in enumerate(models):
            move_cursor(content_x + 8, info_y + 2 + i * 2)
            if i == selected_model:
                print(f"{Colors.BG_ORANGE}{Colors.WHITE} [{model}] {desc} {Colors.RESET}")
            else:
                print(f" [{model}] {desc} ")
    
    # Draw initial options
    draw_model_options()
    
    # Navigation hint
    move_cursor(content_x + 4, info_y + 9)
    print(f"{Colors.DIM}‚Üë‚Üì navigate | enter select | esc cancel{Colors.RESET}")
    
    # Model selection loop
    hide_cursor()
    while True:
        key = get_single_key()
        
        if key == '\x1b[A' or key == 'UP':  # Up arrow
            if selected_model > 0:
                selected_model -= 1
                draw_model_options()
        elif key == '\x1b[B' or key == 'DOWN':  # Down arrow
            if selected_model < len(models) - 1:
                selected_model += 1
                draw_model_options()
        elif key == '\r' or key == 'ENTER':  # Enter - launch claude
            model_name = models[selected_model][0]
            launch_claude_with_model(model_name, content_x, info_y + 11, content_width)
            break
        elif key == 'ESC' or key == '\x1b':  # Escape - cancel
            menu_state.in_submenu = 'tools'
            return
    
    # Return to menu
    menu_state.in_submenu = 'tools'

def launch_claude_with_model(model, content_x, launch_y, content_width):
    """Launch Claude CLI with specific model"""
    move_cursor(content_x + 4, launch_y)
    print(f"{Colors.DIM}launching claude {model} session...{Colors.RESET}")
    
    time.sleep(0.5)
    
    try:
        # Check if claude cli module exists
        from claude_cli import ClaudeCLI
        
        # Clear screen for full Claude experience
        clear_screen()
        show_cursor()
        
        # Initialize and run claude CLI with menu
        claude = ClaudeCLI()
        claude.run_interactive_session()
        
        # After claude exits, handle exit options
        handle_claude_exit()
        
    except ImportError:
        # Fallback to direct claude command if module not found
        result = subprocess.run(['which', 'claude'], capture_output=True, text=True)
        if result.returncode != 0:
            # Claude not installed - show installation message
            move_cursor(content_x + 4, launch_y + 2)
            print(f"{Colors.RED}error: claude cli not found{Colors.RESET}")
            move_cursor(content_x + 4, launch_y + 3)
            print(f"{Colors.YELLOW}please install claude cli first{Colors.RESET}")
            move_cursor(content_x + 4, launch_y + 5)
            print(f"{Colors.DIM}press enter to continue...{Colors.RESET}", end='')
            input()
            return
        
        # Run claude directly
        clear_screen()
        show_cursor()
        
        if model != "default":
            cmd = f"claude --model {model}"
        else:
            cmd = "claude"
        
        subprocess.run(cmd, shell=True)
        handle_claude_exit()
        
    except Exception as e:
        print(f"{Colors.RED}error: {str(e)}{Colors.RESET}")
        print(f"\n{Colors.DIM}press enter to continue...{Colors.RESET}")
        input()

def handle_claude_exit():
    """Handle exit from Claude session with version creation option"""
    try:
        clear_screen()
        print(f"{Colors.CYAN}claude session ended{Colors.RESET}\n")
        print(f"What would you like to do?\n")
        print(f"1. Return to unibos menu")
        print(f"2. Save changes and create new version (exit unibos)")
        print(f"\n{Colors.DIM}Enter choice (1 or 2): {Colors.RESET}", end='')
        
        choice = input().strip()
        
        if choice == '1':
            # Return to main menu
            menu_state.in_submenu = 'tools'
            return
        elif choice == '2':
            # Run version manager to create new version
            print(f"\n{Colors.YELLOW}Creating new version...{Colors.RESET}")
        try:
            # Get version description
            print(f"\n{Colors.CYAN}Enter version description: {Colors.RESET}", end='')
            description = input().strip() or "Claude AI assisted development"
            
            # Update VERSION.json description
            version_file = "/Users/berkhatirli/Desktop/unibos/src/VERSION.json"
            if os.path.exists(version_file):
                with open(version_file, 'r') as f:
                    version_data = json.loads(f.read())
                version_data['description'] = description
                with open(version_file, 'w') as f:
                    json.dump(version_data, f, indent=2)
            
            # Run version manager script
            print(f"\n{Colors.GREEN}Running version manager...{Colors.RESET}")
            result = subprocess.run(["/Users/berkhatirli/Desktop/unibos/src/version_manager.sh"], 
                                    input="e\n", text=True, capture_output=True)
            
            if result.returncode == 0:
                print(f"\n{Colors.GREEN}‚úì Version created successfully{Colors.RESET}")
                print(f"{Colors.YELLOW}Restarting unibos with new version...{Colors.RESET}")
                time.sleep(2)
                
                # Exit current process and restart unibos.sh
                os.execv('/Users/berkhatirli/Desktop/unibos/unibos.sh', ['unibos.sh'])
            else:
                print(f"\n{Colors.RED}Error creating version:{Colors.RESET}")
                print(result.stderr)
                print(f"\n{Colors.DIM}Press enter to return to menu...{Colors.RESET}")
                input()
            
        except Exception as e:
            print(f"\n{Colors.RED}Error: {e}{Colors.RESET}")
            print(f"{Colors.DIM}Press enter to return to menu...{Colors.RESET}")
            input()
        else:
            # Invalid choice - return to menu
            print(f"\n{Colors.YELLOW}Invalid choice. Returning to menu...{Colors.RESET}")
            time.sleep(1)
            menu_state.in_submenu = 'tools'
            return
    except KeyboardInterrupt:
        # Handle Ctrl+C
        print(f"\n\n{Colors.YELLOW}Interrupted. Returning to menu...{Colors.RESET}")
        time.sleep(1)
        menu_state.in_submenu = 'tools'
        return
    except Exception as e:
        print(f"\n{Colors.RED}Error in handle_claude_exit: {e}{Colors.RESET}")
        print(f"{Colors.DIM}Press enter to return to menu...{Colors.RESET}")
        input()
        menu_state.in_submenu = 'tools'
        return

def handle_tool_launch(tool_key):
    """Handle tool launch from sidebar"""
    menu_state.in_submenu = tool_key
    
    if tool_key == 'system_scrolls':
        show_system_scrolls()
    elif tool_key == 'castle_guard':
        show_castle_guard()
    elif tool_key == 'forge_smithy':
        show_forge_smithy()
    elif tool_key == 'anvil_repair':
        show_anvil_repair()
    elif tool_key == 'web_forge':
        # Launch web forge menu
        menu_state.in_submenu = 'web_forge'
        menu_state.web_forge_index = 0
        draw_web_forge_menu()
        handle_web_forge_menu()
    else:
        # Generic tool display
        show_tool_screen(tool_key)

def show_tool_screen(tool_key):
    """Generic tool screen display"""
    cols, lines = get_terminal_size()
    content_x = 27  # After sidebar
    content_width = cols - content_x - 1
    
    # Find tool info
    tool_info = None
    for key, name, desc, available, action in menu_state.tools:
        if key == tool_key:
            tool_info = (name, desc)
            break
    
    if not tool_info:
        return
    
    name, desc = tool_info
    
    # Clear content area
    for y in range(3, lines - 1):
        move_cursor(content_x, y)
        print(' ' * content_width, end='', flush=True)
    
    # Draw content box
    draw_box(content_x, 3, content_width - 1, lines - 4, name, Colors.BLUE)
    
    # Display content
    y = 5
    move_cursor(content_x + 3, y)
    print(f"{Colors.BOLD}description:{Colors.RESET} {desc}")
    y += 2
    move_cursor(content_x + 3, y)
    print(f"{Colors.BOLD}status:{Colors.RESET} {Colors.GREEN}ready{Colors.RESET}")
    y += 3
    
    move_cursor(content_x + 3, y)
    print(f"{Colors.YELLOW}üöß Feature coming soon!{Colors.RESET}")
    y += 2
    
    move_cursor(content_x + 3, y)
    print(f"{Colors.DIM}This tool is under development and will be available in a future update.{Colors.RESET}")
    
    # Navigation hint
    move_cursor(content_x + 3, lines - 5)
    print(f"{Colors.DIM}press enter to launch{Colors.RESET}")
    
    # Wait for key
    while True:
        key = get_single_key(timeout=0.1)
        if key == '\x1b' or key == '\x1b[D' or key == 'q':  # ESC, Left Arrow, or q
            menu_state.in_submenu = None
            draw_main_screen()
            break
        elif key == '\r':  # Enter
            # Show coming soon message
            move_cursor(content_x + 3, lines - 7)
            print(f"{Colors.ORANGE}‚ö° Launching soon...{Colors.RESET}")
            time.sleep(1)

def show_castle_guard():
    """Show security tools screen"""
    show_tool_screen('castle_guard')

def show_forge_smithy():
    """Show setup tools screen"""
    show_tool_screen('forge_smithy')

def show_anvil_repair():
    """Show repair tools screen"""
    show_tool_screen('anvil_repair')

def show_system_scrolls():
    """Display system information using system_scrolls module"""
    cols, lines = get_terminal_size()
    content_x = 27  # After sidebar
    content_width = cols - content_x - 2
    
    # Clear content area
    for y in range(3, lines - 1):
        move_cursor(content_x, y)
        print(' ' * content_width, end='', flush=True)
    
    # Draw content box
    draw_box(content_x, 3, content_width - 1, lines - 4, "üìä System Scrolls", Colors.ORANGE)
    
    try:
        from system_scrolls import SystemScrolls
        scrolls = SystemScrolls()
        info = scrolls.get_all_info()
        
        # Display content
        y = 5
        max_y = lines - 5
        
        # OS Info
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}{Colors.ORANGE}System Information:{Colors.RESET}")
        y += 2
        
        # Format and display each section
        sections = []
        
        # OS information
        os_info = info.get('os', {})
        net_info = info.get('network', {})
        sections.extend([
            ("OS", f"{os_info.get('system', 'Unknown')} {os_info.get('release', '')}"),
            ("Platform", os_info.get('platform', 'Unknown')),
            ("Machine", os_info.get('machine', 'Unknown')),
            ("Hostname", net_info.get('hostname', os_info.get('node', 'Unknown'))),
        ])
        
        # Python information
        py_info = info.get('python', {})
        ver_info = py_info.get('version_info', {})
        py_version = f"{ver_info.get('major', 0)}.{ver_info.get('minor', 0)}.{ver_info.get('micro', 0)}"
        sections.append(("Python", py_version))
        
        # CPU information
        cpu_info = info.get('cpu', {})
        if cpu_info:
            sections.extend([
                ("", ""),  # Empty line
                ("CPU", cpu_info.get('model', 'Unknown')),
                ("Cores", f"{cpu_info.get('physical_cores', 'Unknown')} physical, {cpu_info.get('logical_cores', 'Unknown')} logical"),
            ])
            if 'usage_percent' in cpu_info:
                sections.append(("Usage", f"{cpu_info['usage_percent']}%"))
        
        # Memory information
        mem_info = info.get('memory', {})
        if mem_info and 'virtual' in mem_info:
            vm = mem_info['virtual']
            sections.extend([
                ("", ""),
                ("RAM", f"{vm.get('total', 'Unknown')} total"),
                ("Used", f"{vm.get('used', 'Unknown')} ({vm.get('percent', 0)}%)"),
                ("Available", vm.get('available', 'Unknown')),
            ])
        
        # Disk information
        disk_info = info.get('disk', {})
        partitions = disk_info.get('partitions', [])
        if partitions:
            sections.extend([
                ("", ""),
                ("Disk", f"{len(partitions)} partition(s)"),
            ])
            for part in partitions[:2]:  # Show first 2 partitions
                sections.append((f"  {part.get('device', 'Unknown')}", f"{part.get('percent', 0)}% used"))
        
        # Display sections
        for label, value in sections:
            if y >= max_y - 2:
                break
            if label:
                move_cursor(content_x + 5, y)
                print(f"{Colors.DIM}{label}:{Colors.RESET} {value}")
            y += 1
        
        # Navigation hint
        move_cursor(content_x + 3, max_y)
        print(f"{Colors.DIM}Press ESC or ‚Üê to go back{Colors.RESET}")
        
    except ImportError as e:
        # Fallback without psutil
        y = 5
        move_cursor(content_x + 3, y)
        print(f"{Colors.YELLOW}System information module not available{Colors.RESET}")
        y += 2
        move_cursor(content_x + 3, y)
        print(f"{Colors.DIM}Error: {str(e)}{Colors.RESET}")
        y += 2
        move_cursor(content_x + 3, y)
        print("Basic system info:")
        y += 2
        
        import platform
        move_cursor(content_x + 5, y)
        print(f"OS: {platform.system()} {platform.release()}")
        y += 1
        move_cursor(content_x + 5, y)
        print(f"Machine: {platform.machine()}")
        y += 1
        move_cursor(content_x + 5, y)
        print(f"Python: {platform.python_version()}")
        
        # Navigation hint
        y = max_y
        move_cursor(content_x + 3, y)
        print(f"{Colors.DIM}Press ESC or ‚Üê to go back{Colors.RESET}")
        
    except Exception as e:
        # General error handling
        y = 5
        move_cursor(content_x + 3, y)
        print(f"{Colors.RED}Error loading system information:{Colors.RESET}")
        y += 2
        move_cursor(content_x + 3, y)
        print(f"{Colors.DIM}{str(e)}{Colors.RESET}")
        y += 2
        
        # Log the full error for debugging
        import traceback
        error_msg = traceback.format_exc()
        lines = error_msg.split('\n')
        for line in lines[:5]:  # Show first 5 lines of traceback
            if y >= max_y - 2:
                break
            move_cursor(content_x + 5, y)
            print(f"{Colors.DIM}{line[:content_width-10]}{Colors.RESET}")
            y += 1
        
        # Navigation hint
        y = max_y
        move_cursor(content_x + 3, y)
        print(f"{Colors.DIM}Press ESC or ‚Üê to go back{Colors.RESET}")
    
    # Wait for key
    while True:
        key = get_single_key(timeout=0.1)
        if key == '\x1b' or key == '\x1b[D' or key == 'q':  # ESC, Left Arrow, or q
            menu_state.in_submenu = None
            draw_main_screen()
            break

def handle_tool_selection():
    """Handle tool selection in sidebar (admin tools)"""
    # Get selected tool from the admin tools list
    if menu_state.selected_index < len(menu_state.tools):
        key, name, desc = menu_state.tools[menu_state.selected_index]
        
        if key == 'system_info':
            menu_state.in_submenu = 'system_info'
            show_system_scrolls()
        elif key == 'security_tools':
            menu_state.in_submenu = 'security_tools'
        elif key == 'claude':
            # Launch claude cli in content area
            menu_state.in_submenu = 'claude'
            run_claude_in_content_area()
        elif key == 'git':
            # Launch git manager within main UI
            menu_state.in_submenu = 'git_manager'  # Set special submenu state
            try:
                from git_manager import GitManager
                git_manager = GitManager()
                # Pass the draw_main_screen function as callback
                git_manager.show_main_menu(draw_ui_callback=draw_main_screen)
                # After git manager exits, return to tools menu
                menu_state.in_submenu = 'tools'
            except ImportError as e:
                menu_state.in_submenu = 'tools'
                clear_screen()
                print(f"{Colors.RED}error: git_manager module not found{Colors.RESET}")
                print(f"{Colors.RED}details: {str(e)}{Colors.RESET}")
                time.sleep(2)
            except Exception as e:
                menu_state.in_submenu = 'tools'
                clear_screen()
                print(f"{Colors.RED}error: {e}{Colors.RESET}")
                time.sleep(2)
        else:
            # Show coming soon message
            cols, lines = get_terminal_size()
            move_cursor(cols // 2 - 10, lines // 2)
            print(f"{Colors.YELLOW}feature coming soon!{Colors.RESET}")
            time.sleep(1)

def show_module_screen(module_key):
    """Generic module screen display (like web forge)"""
    cols, lines = get_terminal_size()
    content_x = 27  # After sidebar
    content_width = cols - content_x - 1
    
    # Find module info
    module_info = None
    for key, name, desc, available, action in menu_state.modules:
        if key == module_key:
            module_info = (name, desc)
            break
    
    if not module_info:
        return
    
    name, desc = module_info
    
    # Clear content area
    for y in range(3, lines - 1):
        move_cursor(content_x, y)
        print(' ' * content_width, end='', flush=True)
    
    # Draw content box
    draw_box(content_x, 3, content_width - 1, lines - 4, name, Colors.CYAN)
    
    # Display content
    y = 5
    move_cursor(content_x + 3, y)
    print(f"{Colors.BOLD}description:{Colors.RESET} {desc}")
    y += 2
    move_cursor(content_x + 3, y)
    print(f"{Colors.BOLD}status:{Colors.RESET} {Colors.GREEN}ready{Colors.RESET}")
    y += 3
    
    # Module-specific content
    if module_key == 'recaria':
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}consciousness:{Colors.RESET} {Colors.MAGENTA}1 / 8.000.000.000{Colors.RESET}")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}collective mind:{Colors.RESET} {Colors.YELLOW}‚àû past + present + future{Colors.RESET}")
        y += 3
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}philosophy:{Colors.RESET}")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"consciousness = lived experiences")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"           + present influence")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"           + future potential")
        y += 3
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}next 2 years:{Colors.RESET}")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ quantum communication")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ metaverse migration")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ neura-link awakening")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ global crisis sync")
        y += 3
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}game features:{Colors.RESET}")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ shape collective reality")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"{Colors.DIM}press enter to launch{Colors.RESET}")
        
    elif module_key == 'birlikteyiz':
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}network type:{Colors.RESET} LoRa Mesh Network")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}frequency:{Colors.RESET} 868 MHz (EU) / 915 MHz (US)")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}range:{Colors.RESET} up to 15 km")
        y += 3
        move_cursor(content_x + 3, y)
        print(f"{Colors.YELLOW}üöß Hardware required:{Colors.RESET}")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ Raspberry Pi or compatible")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ LoRa HAT/Module")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ Antenna")
        
    elif module_key == 'kisisel':
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}features:{Colors.RESET}")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ Track personal expenses")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ Calculate real inflation")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ Compare with official rates")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ Historical analysis")
        
    elif module_key == 'currencies':
        move_cursor(content_x + 3, y)
        print(f"{Colors.BOLD}supported:{Colors.RESET}")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ 10+ fiat currencies")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ 10+ cryptocurrencies")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ Real-time rates")
        y += 1
        move_cursor(content_x + 3, y)
        print(f"‚Ä¢ Portfolio tracking")
    
    # Navigation hint
    move_cursor(content_x + 3, lines - 5)
    print(f"{Colors.DIM}press enter to launch{Colors.RESET}")
    
    # Wait for key
    while True:
        key = get_single_key(timeout=0.1)
        if key == '\x1b' or key == '\x1b[D' or key == 'q':  # ESC, Left Arrow, or q
            menu_state.in_submenu = None
            draw_main_screen()
            break
        elif key == '\r':  # Enter
            # Launch the actual module
            if module_key == 'recaria':
                show_recaria_submenu()
            elif module_key == 'birlikteyiz':
                launch_birlikteyiz()
            elif module_key == 'kisisel':
                launch_kisisel()
            elif module_key == 'currencies':
                launch_currencies()
            break

def launch_birlikteyiz():
    """Launch birlikteyiz module"""
    clear_screen()
    print(f"{Colors.CYAN}{'='*50}{Colors.RESET}")
    print(f"{Colors.BOLD}üöÄ launching birlikteyiz...{Colors.RESET}")
    print(f"{Colors.CYAN}{'='*50}{Colors.RESET}\n")
    print(f"üì° {t('birlikteyiz')} - mesh network")
    print(f"{Colors.GREEN}initializing lora network...{Colors.RESET}")
    try:
        from projects.birlikteyiz.main import main as birlikteyiz_main
        birlikteyiz_main()
    except ImportError:
        print(f"{Colors.YELLOW}birlikteyiz module not found.{Colors.RESET}")
    print(f"\n{Colors.DIM}press enter to continue...{Colors.RESET}")
    input()
    menu_state.in_submenu = None
    draw_main_screen()

def launch_kisisel():
    """Launch kisisel enflasyon module"""
    clear_screen()
    print(f"{Colors.CYAN}{'='*50}{Colors.RESET}")
    print(f"{Colors.BOLD}üöÄ launching ki≈üisel enflasyon...{Colors.RESET}")
    print(f"{Colors.CYAN}{'='*50}{Colors.RESET}\n")
    print(f"üìà {t('kisisel')} - personal inflation calculator")
    try:
        from personal_inflation import show_inflation_menu
        show_inflation_menu()
    except ImportError:
        try:
            from projects.kisiselenflasyon.main import main as inflation_main
            inflation_main()
        except ImportError:
            print(f"{Colors.YELLOW}ki≈üisel enflasyon module not found.{Colors.RESET}")
    print(f"\n{Colors.DIM}press enter to continue...{Colors.RESET}")
    input()
    menu_state.in_submenu = None
    draw_main_screen()

def launch_currencies():
    """Launch currencies module"""
    clear_screen()
    print(f"{Colors.CYAN}{'='*50}{Colors.RESET}")
    print(f"{Colors.BOLD}üöÄ launching currencies...{Colors.RESET}")
    print(f"{Colors.CYAN}{'='*50}{Colors.RESET}\n")
    print(f"üí∞ {t('currencies')} - exchange rates")
    try:
        from currencies_enhanced import CurrenciesModule
        module = CurrenciesModule()
        module.run()
    except ImportError:
        try:
            from projects.currencies.main import main as currencies_main
            currencies_main()
        except ImportError:
            print(f"{Colors.YELLOW}currencies module not found.{Colors.RESET}")
    print(f"\n{Colors.DIM}press enter to continue...{Colors.RESET}")
    input()
    menu_state.in_submenu = None
    draw_main_screen()

def handle_module_launch(module_key):
    """Handle module launch"""
    menu_state.in_submenu = module_key
    show_module_screen(module_key)


def update_module_selection(index):
    """Update visual selection for modules"""
    # Store previous index before updating
    menu_state.previous_index = menu_state.selected_index
    
    # Update menu state
    menu_state.selected_index = index
    menu_state.current_section = 0  # 0 for modules
    
    # Flush before updating to prevent artifacts
    sys.stdout.flush()
    
    # Only update the sidebar selection visual, not entire screen
    update_sidebar_selection()
    hide_cursor()
    
    # Return the new index for synchronization
    return index

def update_tool_selection(index):
    """Update visual selection for tools"""
    # Store previous index before updating
    menu_state.previous_index = menu_state.selected_index
    
    # Update menu state
    menu_state.selected_index = index
    menu_state.current_section = 1  # 1 for tools
    
    # Flush before updating to prevent artifacts
    sys.stdout.flush()
    
    # Only update the sidebar selection visual, not entire screen
    update_sidebar_selection()
    hide_cursor()
    
    # Return the new index for synchronization
    return index

def update_dev_tool_selection(index):
    """Update visual selection for dev tools"""
    # Store previous index before updating
    menu_state.previous_index = menu_state.selected_index
    
    # Update menu state
    menu_state.selected_index = index
    menu_state.current_section = 2  # 2 for dev tools
    
    # Flush before updating to prevent artifacts
    sys.stdout.flush()
    
    # Only update the sidebar selection visual, not entire screen
    update_sidebar_selection()
    hide_cursor()
    
    # Return the new index for synchronization
    return index

def get_tool_icon(name):
    """Get icon for tool based on name"""
    name_lower = name.lower()
    if "system" in name_lower: return "üìä"
    elif "security" in name_lower: return "üîí"
    elif "claude" in name_lower: return "ü§ñ"
    elif "setup" in name_lower: return "üîß"
    elif "repair" in name_lower: return "üõ†Ô∏è"
    elif "git" in name_lower: return "üì¶"
    elif "web" in name_lower: return "üåê"
    elif "sd" in name_lower: return "üíæ"
    else: return "‚öôÔ∏è"

def main_loop():
    """Main application loop - with safe arrow key navigation"""
    global CURRENT_LANG
    
    # Clear input buffer multiple times to ensure it's empty
    if TERMIOS_AVAILABLE:
        try:
            import termios
            # Flush multiple times to ensure buffer is completely clear
            for _ in range(3):
                termios.tcflush(sys.stdin, termios.TCIFLUSH)
                time.sleep(0.01)
        except:
            pass
    
    # Longer delay to ensure terminal is fully ready after splash
    time.sleep(0.2)
    
    # Initialize menu items first
    initialize_menu_items()
    
    # Track last footer update time and last keypress
    last_footer_update = time.time()
    last_keypress_time = 0
    min_keypress_interval = 0.05  # 50ms debounce
    
    # Initial screen draw
    draw_main_screen()
    
    # Initialize terminal size for resize detection
    menu_state.last_cols, menu_state.last_lines = get_terminal_size()
    
    # Initialize selected module/tool indices and sync with menu_state
    menu_state.selected_index = 0
    menu_state.current_section = 0  # 0 for modules, 1 for tools, 2 for dev tools
    menu_state.previous_index = None  # Initialize previous index
    selected_module = 0
    selected_tool = 0
    selected_dev_tool = 0
    
    # Simple initialization - no complex buffer clearing
    if menu_state.modules:
        # Single buffer clear after splash screen
        if TERMIOS_AVAILABLE:
            try:
                termios.tcflush(sys.stdin, termios.TCIFLUSH)
            except:
                pass
        
        # Initial display with selection
        update_sidebar_selection()
        hide_cursor()
    
    # Track if this is the first keypress
    first_keypress = True
    
    while True:
        try:
            # Check for terminal resize
            cols, lines = get_terminal_size()
            if cols != menu_state.last_cols or lines != menu_state.last_lines:
                menu_state.last_cols = cols
                menu_state.last_lines = lines
                # Redraw everything on resize
                clear_screen()
                draw_main_screen()
            
            # Update footer every second for live clock
            current_time = time.time()
            if current_time - last_footer_update >= 1.0:
                draw_footer(only_time=True)  # Only update time to prevent flicker
                last_footer_update = current_time
                hide_cursor()
            
            # Get single key input with arrow support
            key = get_single_key(timeout=0.1)
            
            # If no key pressed, continue loop
            if not key:
                continue
            
            # Mark first keypress done
            if first_keypress:
                first_keypress = False
            
            # Debounce - prevent too rapid keypresses
            current_keypress_time = time.time()
            if current_keypress_time - last_keypress_time < min_keypress_interval:
                # Clear any remaining input in buffer
                if TERMIOS_AVAILABLE:
                    try:
                        termios.tcflush(sys.stdin, termios.TCIFLUSH)
                    except:
                        pass
                continue
            last_keypress_time = current_keypress_time
            
            # Debug output for key detection
            if os.environ.get('UNIBOS_DEBUG', '').lower() == 'true':
                with open('/tmp/unibos_main_debug.log', 'a') as f:
                    f.write(f"Main loop received key: {repr(key)}\n")
                    f.flush()
            
            # Handle navigation keys
            if key == '\x1b[D' or (key == '\x1b' and menu_state.in_submenu):  # Left arrow or ESC in submenu
                if menu_state.in_submenu:
                    menu_state.in_submenu = None
                    draw_main_screen()
                continue
            
            # Handle quit command - only 'q' should quit from main menu
            if key and key.lower() == 'q' and not menu_state.in_submenu:  # Only q quits from main menu
                break
            
            # Handle arrow keys FIRST before checking for ESC alone
            if key == '\x1b[A':  # Up arrow
                try:
                    if menu_state.current_section == 0:  # modules
                        if selected_module > 0:
                            selected_module -= 1
                            selected_module = update_module_selection(selected_module)
                        elif menu_state.dev_tools:  # At top of modules, go to bottom of dev tools
                            # Clear old highlight before switching section
                            menu_state.current_section = 2
                            selected_dev_tool = len(menu_state.dev_tools) - 1
                            menu_state.selected_index = selected_dev_tool
                            draw_sidebar()  # Redraw to clear ghost highlights
                            draw_main_content()
                    elif menu_state.current_section == 1:  # tools
                        if selected_tool > 0:
                            selected_tool -= 1
                            selected_tool = update_tool_selection(selected_tool)
                        elif menu_state.modules:  # At top of tools, go to bottom of modules
                            # Clear old highlight before switching section
                            menu_state.current_section = 0
                            selected_module = len(menu_state.modules) - 1
                            menu_state.selected_index = selected_module
                            draw_sidebar()  # Redraw to clear ghost highlights
                            draw_main_content()
                    elif menu_state.current_section == 2:  # dev tools
                        if selected_dev_tool > 0:
                            selected_dev_tool -= 1
                            selected_dev_tool = update_dev_tool_selection(selected_dev_tool)
                        elif menu_state.tools:  # At top of dev tools, go to bottom of tools
                            # Clear old highlight before switching section
                            menu_state.current_section = 1
                            selected_tool = len(menu_state.tools) - 1
                            menu_state.selected_index = selected_tool
                            draw_sidebar()  # Redraw to clear ghost highlights
                            draw_main_content()
                except Exception as e:
                    print(f"\n{Colors.RED}Arrow key error: {e}{Colors.RESET}")
                    time.sleep(1)
                    draw_main_screen()
            
            elif key == '\x1b[B':  # Down arrow
                try:
                    if menu_state.current_section == 0:  # modules
                        if menu_state.modules and selected_module < len(menu_state.modules) - 1:
                            selected_module += 1
                            selected_module = update_module_selection(selected_module)
                        elif menu_state.tools:  # At bottom of modules, go to top of tools
                            # Clear old highlight before switching section
                            menu_state.current_section = 1
                            selected_tool = 0
                            menu_state.selected_index = selected_tool
                            draw_sidebar()  # Redraw to clear ghost highlights
                            draw_main_content()
                    elif menu_state.current_section == 1:  # tools
                        if menu_state.tools and selected_tool < len(menu_state.tools) - 1:
                            selected_tool += 1
                            selected_tool = update_tool_selection(selected_tool)
                        elif menu_state.dev_tools:  # At bottom of tools, go to top of dev tools
                            # Clear old highlight before switching section
                            menu_state.current_section = 2
                            selected_dev_tool = 0
                            menu_state.selected_index = selected_dev_tool
                            draw_sidebar()  # Redraw to clear ghost highlights
                            draw_main_content()
                    elif menu_state.current_section == 2:  # dev tools
                        if menu_state.dev_tools and selected_dev_tool < len(menu_state.dev_tools) - 1:
                            selected_dev_tool += 1
                            selected_dev_tool = update_dev_tool_selection(selected_dev_tool)
                        elif menu_state.modules:  # At bottom of dev tools, wrap to top of modules
                            # Clear old highlight before switching section
                            menu_state.current_section = 0
                            selected_module = 0
                            menu_state.selected_index = selected_module
                            draw_sidebar()  # Redraw to clear ghost highlights
                            draw_main_content()
                except Exception as e:
                    print(f"\n{Colors.RED}Arrow key error: {e}{Colors.RESET}")
                    time.sleep(1)
                    draw_main_screen()
            
            elif key == '\x1b[D' or (key == '\x1b' and menu_state.in_submenu):  # Left arrow or ESC in submenu
                # Handle back navigation
                if menu_state.in_submenu:
                    # Exit from submenu
                    menu_state.in_submenu = None
                    draw_main_screen()
                # If not in submenu, left arrow does nothing
            
            elif key == '\r' or key == '\x1b[C':  # Enter or Right arrow
                if menu_state.current_section == 0 and 0 <= selected_module < len(menu_state.modules):
                    cmd, name, desc, available, action = menu_state.modules[selected_module]
                    if available and action:
                        action()
                    draw_main_screen()
                elif menu_state.current_section == 1 and 0 <= selected_tool < len(menu_state.tools):
                    cmd, name, desc, available, action = menu_state.tools[selected_tool]
                    if available and action:
                        action()
                    draw_main_screen()
                elif menu_state.current_section == 2 and 0 <= selected_dev_tool < len(menu_state.dev_tools):
                    cmd, name, desc, available, action = menu_state.dev_tools[selected_dev_tool]
                    if available and action:
                        action()
                    draw_main_screen()
            
            elif key == '\t':  # Tab to switch sections
                if menu_state.current_section == 0:  # modules
                    # Clear previous highlight completely
                    if 0 <= menu_state.selected_index < len(menu_state.modules):
                        y_pos = 6 + menu_state.selected_index  # Single line spacing
                        move_cursor(2, y_pos)
                        name = menu_state.modules[menu_state.selected_index][1]
                        print(f"{Colors.BG_GRAY}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}", end='', flush=True)
                    # Switch to tools
                    selected_tool = 0
                    menu_state.current_section = 1
                    menu_state.selected_index = selected_tool
                    # Redraw entire sidebar
                    draw_sidebar()
                    draw_main_content()
                elif menu_state.current_section == 1:  # tools
                    # Clear previous highlight completely
                    if 0 <= menu_state.selected_index < len(menu_state.tools):
                        y_pos = menu_state.tools_start_y + 2 + menu_state.selected_index  # Single line spacing
                        move_cursor(2, y_pos)
                        name = menu_state.tools[menu_state.selected_index][1]
                        print(f"{Colors.BG_GRAY}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}", end='', flush=True)
                    # Switch to dev tools
                    selected_dev_tool = 0
                    menu_state.current_section = 2
                    menu_state.selected_index = selected_dev_tool
                    # Redraw entire sidebar
                    draw_sidebar()
                    draw_main_content()
                else:  # dev tools (section 2)
                    # Clear previous highlight completely
                    if 0 <= menu_state.selected_index < len(menu_state.dev_tools):
                        y_pos = menu_state.dev_tools_start_y + 2 + menu_state.selected_index  # Single line spacing
                        move_cursor(2, y_pos)
                        name = menu_state.dev_tools[menu_state.selected_index][1]
                        print(f"{Colors.BG_GRAY}{Colors.WHITE} {name[:22]:<22} {Colors.RESET}", end='', flush=True)
                    # Switch to modules
                    selected_module = 0
                    menu_state.current_section = 0
                    menu_state.selected_index = selected_module
                    # Redraw entire sidebar
                    draw_sidebar()
                    draw_main_content()
            
            
            # Language menu toggle
            elif key and key.lower() == 'l':
                menu_state.in_language_menu = True
                menu_state.language_selected_index = 0
                languages = get_available_languages()
                
                # Language selection loop with clock updates
                lang_last_update = time.time()
                while menu_state.in_language_menu:
                    # Update clock while in language menu
                    current_time = time.time()
                    if current_time - lang_last_update >= 1.0:
                        draw_footer(only_time=True)
                        lang_last_update = current_time
                    
                    show_language_selection()
                    lang_key = get_single_key(timeout=0.1)  # Short timeout for clock updates
                    
                    if lang_key:  # Only process if we got a key
                        if lang_key == '\x1b[A':  # Up arrow
                            if menu_state.language_selected_index > 0:
                                menu_state.language_selected_index -= 1
                        elif lang_key == '\x1b[B':  # Down arrow
                            if menu_state.language_selected_index < min(9, len(languages) - 1):
                                menu_state.language_selected_index += 1
                        elif lang_key == '\r':  # Enter
                            # Select the language
                            global CURRENT_LANG
                            code, name, flag = languages[menu_state.language_selected_index]
                            CURRENT_LANG = code
                            initialize_menu_items()
                            menu_state.in_language_menu = False
                        elif lang_key == '\x1b' or (lang_key and lang_key.lower() == 'l'):  # ESC or L to close
                            menu_state.in_language_menu = False
                        elif lang_key.isdigit():
                            # Number selection for backward compatibility
                            num = int(lang_key) if lang_key != '0' else 10
                            if num <= len(languages[:10]):
                                code, name, flag = languages[num - 1]
                                CURRENT_LANG = code
                                initialize_menu_items()
                                menu_state.in_language_menu = False
                
                draw_main_screen()  # Redraw after language selection
                continue
            
            # Handle module commands
            for i, (cmd, name, desc, available, action) in enumerate(menu_state.modules):
                if key == cmd:
                    if available:
                        if action:
                            action()
                        else:
                            print(f"\n{Colors.YELLOW}Module {name} not implemented yet.{Colors.RESET}")
                            time.sleep(2)
                    else:
                        print(f"\n{Colors.RED}Module {name} is not available.{Colors.RESET}")
                        time.sleep(2)
                    draw_main_screen()
                    continue
            
            # Handle tool commands
            for i, (cmd, name, desc, available, action) in enumerate(menu_state.tools):
                if key == cmd:
                    if available:
                        if action:
                            action()
                        else:
                            print(f"\n{Colors.YELLOW}Tool {name} not implemented yet.{Colors.RESET}")
                            time.sleep(2)
                    else:
                        print(f"\n{Colors.RED}Tool {name} is not available.{Colors.RESET}")
                        time.sleep(2)
                    draw_main_screen()
                    continue
        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"\n{Colors.RED}Error: {e}{Colors.RESET}")
            time.sleep(2)
            draw_main_screen()

def database_setup_wizard():
    """Launch database setup wizard"""
    try:
        from database_setup_wizard import DatabaseSetupWizard
        
        # Save current terminal state
        show_cursor()
        clear_screen()
        
        # Run wizard
        wizard = DatabaseSetupWizard()
        wizard.run_wizard()
        
        # Restore screen
        hide_cursor()
        draw_main_screen()
        
    except ImportError as e:
        clear_screen()
        print(f"\n{Colors.RED}Error loading Database Setup Wizard: {e}{Colors.RESET}")
        time.sleep(2)
        hide_cursor()
        draw_main_screen()
    except Exception as e:
        clear_screen()
        print(f"\n{Colors.RED}Error in Database Setup: {e}{Colors.RESET}")
        time.sleep(2)
        hide_cursor()
        draw_main_screen()

def start_web_backend():
    """Enhanced Django backend server start with pre-flight checks"""
    show_server_action("‚öôÔ∏è Starting Backend Forge", Colors.CYAN)
    
    cols, lines = get_terminal_size()
    content_x = 27 + 4
    y = 5
    
    backend_path = Path('/Users/berkhatirli/Desktop/unibos/backend')
    
    # Pre-flight checks
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}Running pre-flight checks...{Colors.RESET}")
    y += 2
    
    # Check if backend exists
    if not backend_path.exists():
        move_cursor(content_x, y)
        print(f"{Colors.RED}‚úó Backend directory not found!{Colors.RESET}")
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}Solution: Run Setup Wizard to initialize backend{Colors.RESET}")
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
        get_single_key()
        return
    
    # Check Python
    python_ok, python_msg = check_python_version()
    move_cursor(content_x, y)
    if python_ok:
        print(f"{Colors.GREEN}‚úì Python: {python_msg}{Colors.RESET}")
    else:
        print(f"{Colors.RED}‚úó Python: {python_msg}{Colors.RESET}")
    y += 1
    
    # Check virtual environment
    venv_exists = (backend_path / 'venv').exists() or (backend_path / '.venv').exists()
    move_cursor(content_x, y)
    if venv_exists:
        print(f"{Colors.GREEN}‚úì Virtual environment found{Colors.RESET}")
    else:
        print(f"{Colors.YELLOW}‚ö† No virtual environment{Colors.RESET}")
    y += 1
    
    # Check port availability
    port_ok, port_msg = check_port_available(8000)
    move_cursor(content_x, y)
    if port_ok:
        print(f"{Colors.GREEN}‚úì Port 8000: {port_msg}{Colors.RESET}")
    else:
        print(f"{Colors.RED}‚úó Port 8000: {port_msg}{Colors.RESET}")
        y += 1
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}Another server may be running. Stop it first.{Colors.RESET}")
    y += 2
    
    if not python_ok or not port_ok:
        move_cursor(content_x, y)
        print(f"{Colors.RED}Cannot start server. Fix issues above first.{Colors.RESET}")
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
        get_single_key()
        return
    
    # Show start options
    move_cursor(content_x, y)
    print(f"{Colors.CYAN}Ready to start Django backend server!{Colors.RESET}")
    y += 2
    
    move_cursor(content_x, y)
    print(f"{Colors.WHITE}Server details:{Colors.RESET}")
    y += 1
    
    details = [
        f"üìÅ Directory: {backend_path}",
        f"üåê URL: http://localhost:8000",
        f"üìù API: http://localhost:8000/api/",
        f"üìñ Admin: http://localhost:8000/admin/"
    ]
    
    for detail in details:
        move_cursor(content_x + 2, y)
        print(f"{Colors.DIM}{detail}{Colors.RESET}")
        y += 1
    
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}[r]{Colors.RESET} Run server automatically")
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}[m]{Colors.RESET} Show manual commands")
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}[ESC]{Colors.RESET} Cancel")
    
    # Wait for user choice
    key = get_single_key()
    
    if key == '\x1b':  # ESC
        return
    elif key == 'r':
        # Run automatically
        show_server_action("‚öôÔ∏è Backend Starting...", Colors.GREEN)
        move_cursor(content_x, 5)
        print(f"{Colors.GREEN}Starting Django development server...{Colors.RESET}")
        
        # Change to backend directory and run server
        os.chdir(backend_path)
        
        # Activate venv and run server
        activate_cmd = 'source venv/bin/activate' if platform.system() != 'Windows' else 'venv\\Scripts\\activate'
        server_cmd = f"{activate_cmd} && python manage.py runserver"
        
        # Run in subprocess so we can capture output
        process = subprocess.Popen(server_cmd, shell=True)
        
        move_cursor(content_x, 7)
        print(f"{Colors.GREEN}‚úì Server started!{Colors.RESET}")
        move_cursor(content_x, 9)
        print(f"{Colors.CYAN}Access at: http://localhost:8000{Colors.RESET}")
        move_cursor(content_x, 11)
        print(f"{Colors.DIM}Server is running in background. Use 'Stop All' to stop it.{Colors.RESET}")
        
        time.sleep(3)
    elif key == 'm':
        # Show manual commands
        show_server_action("üìã Manual Commands", Colors.CYAN)
        y = 5
        
        commands = [
            "# Navigate to backend directory:",
            "cd backend",
            "",
            "# Create virtual environment (if not exists):",
            "python3 -m venv venv",
            "",
            "# Activate virtual environment:",
            "source venv/bin/activate  # Linux/Mac",
            "venv\\Scripts\\activate     # Windows",
            "",
            "# Install dependencies:",
            "pip install -r requirements.txt",
            "",
            "# Run migrations:",
            "python manage.py migrate",
            "",
            "# Start server:",
            "python manage.py runserver"
        ]
        
        for cmd in commands:
            if y < lines - 5:
                move_cursor(content_x, y)
                if cmd.startswith("#"):
                    print(f"{Colors.CYAN}{cmd}{Colors.RESET}")
                elif cmd:
                    print(f"{Colors.WHITE}$ {cmd}{Colors.RESET}")
                y += 1
        
        y += 1
        move_cursor(content_x, y)
        print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
        get_single_key()

def start_web_frontend():
    """Enhanced React frontend server start with pre-flight checks"""
    show_server_action("üé® Starting Frontend Anvil", Colors.CYAN)
    
    cols, lines = get_terminal_size()
    content_x = 27 + 4
    y = 5
    
    frontend_path = Path('/Users/berkhatirli/Desktop/unibos/frontend')
    
    # Pre-flight checks
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}Running pre-flight checks...{Colors.RESET}")
    y += 2
    
    # Check if frontend exists
    if not frontend_path.exists():
        move_cursor(content_x, y)
        print(f"{Colors.RED}‚úó Frontend directory not found!{Colors.RESET}")
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}Solution: Run Setup Wizard to initialize frontend{Colors.RESET}")
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
        get_single_key()
        return
    
    # Check Node.js
    node_ok, node_msg = check_node_version()
    move_cursor(content_x, y)
    if node_ok:
        print(f"{Colors.GREEN}‚úì Node.js: {node_msg}{Colors.RESET}")
    else:
        print(f"{Colors.RED}‚úó Node.js: {node_msg}{Colors.RESET}")
    y += 1
    
    # Check npm
    npm_ok, npm_msg = check_npm_version()
    move_cursor(content_x, y)
    if npm_ok:
        print(f"{Colors.GREEN}‚úì npm: {npm_msg}{Colors.RESET}")
    else:
        print(f"{Colors.RED}‚úó npm: {npm_msg}{Colors.RESET}")
    y += 1
    
    # Check node_modules
    deps_installed = (frontend_path / 'node_modules').exists()
    move_cursor(content_x, y)
    if deps_installed:
        print(f"{Colors.GREEN}‚úì Dependencies installed{Colors.RESET}")
    else:
        print(f"{Colors.YELLOW}‚ö† Dependencies not installed{Colors.RESET}")
        y += 1
        move_cursor(content_x, y)
        print(f"{Colors.DIM}Run 'npm install' first or use Setup Wizard{Colors.RESET}")
    y += 1
    
    # Check port availability
    port_ok, port_msg = check_port_available(3000)
    move_cursor(content_x, y)
    if port_ok:
        print(f"{Colors.GREEN}‚úì Port 3000: {port_msg}{Colors.RESET}")
    else:
        print(f"{Colors.RED}‚úó Port 3000: {port_msg}{Colors.RESET}")
        y += 1
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}Another server may be running. Stop it first.{Colors.RESET}")
    y += 2
    
    if not node_ok or not npm_ok or not port_ok:
        move_cursor(content_x, y)
        print(f"{Colors.RED}Cannot start server. Fix issues above first.{Colors.RESET}")
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
        get_single_key()
        return
    
    if not deps_installed:
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}Dependencies not installed. Install now? (y/n): {Colors.RESET}", end='', flush=True)
        key = get_single_key()
        if key and key.lower() == 'y':
            move_cursor(content_x, y)
            print(f"{Colors.YELLOW}Installing dependencies...{Colors.RESET}")
            os.chdir(frontend_path)
            subprocess.run(['npm', 'install'])
            y += 1
        else:
            return
    
    # Show start options
    move_cursor(content_x, y)
    print(f"{Colors.CYAN}Ready to start React frontend server!{Colors.RESET}")
    y += 2
    
    move_cursor(content_x, y)
    print(f"{Colors.WHITE}Server details:{Colors.RESET}")
    y += 1
    
    details = [
        f"üìÅ Directory: {frontend_path}",
        f"üåê URL: http://localhost:3000",
        f"‚öõÔ∏è Framework: React 18",
        f"üì¶ Build tool: Create React App"
    ]
    
    for detail in details:
        move_cursor(content_x + 2, y)
        print(f"{Colors.DIM}{detail}{Colors.RESET}")
        y += 1
    
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}[r]{Colors.RESET} Run server automatically")
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}[m]{Colors.RESET} Show manual commands")
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}[ESC]{Colors.RESET} Cancel")
    
    # Wait for user choice
    key = get_single_key()
    
    if key == '\x1b':  # ESC
        return
    elif key == 'r':
        # Run automatically
        show_server_action("üé® Frontend Starting...", Colors.GREEN)
        move_cursor(content_x, 5)
        print(f"{Colors.GREEN}Starting React development server...{Colors.RESET}")
        
        # Change to frontend directory and run server
        os.chdir(frontend_path)
        
        # Run npm start
        process = subprocess.Popen(['npm', 'start'])
        
        move_cursor(content_x, 7)
        print(f"{Colors.GREEN}‚úì Server starting!{Colors.RESET}")
        move_cursor(content_x, 9)
        print(f"{Colors.CYAN}Will open at: http://localhost:3000{Colors.RESET}")
        move_cursor(content_x, 11)
        print(f"{Colors.DIM}Server is running in background. Use 'Stop All' to stop it.{Colors.RESET}")
        
        time.sleep(3)
    elif key == 'm':
        # Show manual commands
        show_server_action("üìã Manual Commands", Colors.CYAN)
        y = 5
        
        commands = [
            "# Navigate to frontend directory:",
            "cd frontend",
            "",
            "# Install dependencies (if not done):",
            "npm install",
            "",
            "# Start development server:",
            "npm start",
            "",
            "# Or build for production:",
            "npm run build",
            "",
            "# Run tests:",
            "npm test"
        ]
        
        for cmd in commands:
            if y < lines - 5:
                move_cursor(content_x, y)
                if cmd.startswith("#"):
                    print(f"{Colors.CYAN}{cmd}{Colors.RESET}")
                elif cmd:
                    print(f"{Colors.WHITE}$ {cmd}{Colors.RESET}")
                y += 1
        
        y += 1
        move_cursor(content_x, y)
        print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
        get_single_key()

def web_forge_menu():
    """Enhanced web forge with environment checks and setup wizard"""
    menu_state.in_submenu = 'web_forge'
    menu_state.web_forge_index = 0
    
    # Draw web forge menu in main content area
    draw_web_forge_menu()
    
    # Hide cursor for better visual experience
    hide_cursor()
    
    # Track last footer update time for clock
    last_footer_update = time.time()
    
    while menu_state.in_submenu == 'web_forge':
        # Update footer every second for live clock
        current_time = time.time()
        if current_time - last_footer_update >= 1.0:
            draw_footer(only_time=True)  # Only update time to prevent flicker
            last_footer_update = current_time
            hide_cursor()
        
        # Handle input with timeout for clock updates
        key = get_single_key(timeout=0.1)
        
        # Handle navigation keys
        if key in ['\x1b[A', 'w', 'W', 'k', 'K']:  # Up arrow, w, k
            menu_state.web_forge_index = (menu_state.web_forge_index - 1) % 9  # Updated for 9 options
            draw_web_forge_menu()
            
        elif key in ['\x1b[B', 's', 'S', 'j', 'J']:  # Down arrow, s, j
            menu_state.web_forge_index = (menu_state.web_forge_index + 1) % 9  # Updated for 9 options
            draw_web_forge_menu()
            
        elif key in ['\r', '\n', ' ', '\x1b[C', 'l', 'L']:  # Enter, Space, Right Arrow, or l to select
            # Define selectable options (excluding separators)
            selectable_options = ["env_check", "setup_wizard", "backend", "frontend", "both", "status", "stop", "logs", "back"]
            selected_option = selectable_options[menu_state.web_forge_index]
            
            if selected_option == "env_check":
                run_environment_check()
            elif selected_option == "setup_wizard":
                run_setup_wizard()
            elif selected_option == "backend":
                start_web_backend()
            elif selected_option == "frontend":
                start_web_frontend()
            elif selected_option == "both":
                start_web_both()
            elif selected_option == "status":
                show_web_status()
            elif selected_option == "stop":
                stop_all_web_servers()
            elif selected_option == "logs":
                show_server_logs()
            elif selected_option == "back":
                menu_state.in_submenu = None
                # Ensure dev tools section is selected
                menu_state.current_section = 2  # dev tools section
                menu_state.selected_index = 2  # web launcher is at index 2
                update_sidebar_selection()
                break
                
        elif key == '\x1b' or key in ['q', 'Q', '\x1b[D', 'h', 'H']:  # ESC, q, Left Arrow, or h to go back
            # Return to dev tools menu, not main screen
            menu_state.in_submenu = None
            # Ensure dev tools section is selected
            menu_state.current_section = 2  # dev tools section
            menu_state.selected_index = 2  # web launcher is at index 2
            update_sidebar_selection()
            break
    
    # Return to main screen
    draw_main_screen()

def draw_web_forge_menu():
    """Enhanced web forge menu with environment status"""
    cols, lines = get_terminal_size()
    content_x = 27  # After sidebar
    content_width = cols - content_x - 1  # Full width with minimal margin
    content_height = lines - 4
    
    # Clear content area (without background color)
    for y in range(3, lines - 1):
        move_cursor(content_x, y)
        print(' ' * content_width, end='', flush=True)
    
    # Draw box with medieval style
    draw_box(content_x, 3, content_width - 1, lines - 4, "‚öîÔ∏è  Web Forge  ‚öîÔ∏è", Colors.BLUE)
    
    # Quick environment status check
    env_status = check_environment_quick()
    
    # Show environment status summary
    move_cursor(content_x + 5, 5)
    status_color = Colors.GREEN if env_status['all_good'] else Colors.YELLOW
    status_icon = "‚úì" if env_status['all_good'] else "‚ö†"
    print(f"{status_color}{status_icon} Environment: {env_status['summary']}{Colors.RESET}")
    
    # Web launcher options with medieval theme and grouping
    options = [
        # Setup & Check
        ("env_check", "üîç Environment Check", "Verify all dependencies and tools"),
        ("setup_wizard", "ü™Ñ Setup Wizard", "Initialize backend/frontend if needed"),
        ("separator", "---", "---"),
        # Server Controls
        ("backend", "‚öôÔ∏è Backend Server", "Start Django forge (port 8000)"),
        ("frontend", "üé® Frontend Server", "Start React anvil (port 3000)"),
        ("both", "‚öîÔ∏è Both Servers", "Fire up the entire forge"),
        ("separator", "---", "---"),
        # Status & Logs
        ("status", "üìä Server Status", "Check the forge temperature"),
        ("stop", "üõë Stop All Servers", "Extinguish the forge fires"),
        ("logs", "üìú View Logs", "Read the server chronicles"),
        ("separator", "---", "---"),
        # Navigation
        ("back", "üè∞ Back to Dev Tools", "Return to the main hall"),
    ]
    
    # Calculate layout for better spacing
    start_y = 8  # Start after status line
    y_pos = start_y
    actual_index = 0  # Track actual selectable items
    
    # Display options with better layout and visual sections
    for i, (key, title, desc) in enumerate(options):
        if key == "separator":
            # Draw separator line
            move_cursor(content_x + 3, y_pos)
            separator_width = min(content_width - 8, 60)
            print(f"{Colors.DIM}{'‚îÄ' * separator_width}{Colors.RESET}")
            y_pos += 1
            continue
        elif key == "header":
            # Draw section header
            move_cursor(content_x + 3, y_pos)
            print(f"{Colors.BOLD}{Colors.YELLOW}{title}{Colors.RESET}")
            y_pos += 1
            continue
        
        # Don't draw if it would go past the content area
        if y_pos + 1 >= content_height - 3:
            break
            
        move_cursor(content_x + 3, y_pos)
        if actual_index == menu_state.web_forge_index:
            # Selected option with enhanced visual indicator
            # Draw selection without heavy background
            print(f"{Colors.BOLD}{Colors.WHITE}  ‚ñ∂ {title:<25}{Colors.RESET}", end='')
            # Show description on same line if space allows, otherwise next line
            if content_width > 80:
                print(f" {Colors.WHITE}{desc:<40}{Colors.RESET}", end='')
            else:
                move_cursor(content_x + 7, y_pos + 1)
                print(f"{Colors.WHITE}{desc}{Colors.RESET}", end='')
        else:
            print(f"{Colors.CYAN}    {title:<25}{Colors.RESET}", end='')
            if content_width > 80:
                print(f" {Colors.DIM}{desc}{Colors.RESET}", end='')
            else:
                move_cursor(content_x + 7, y_pos + 1)
                print(f"{Colors.DIM}{desc}{Colors.RESET}", end='')
        
        y_pos += 2  # Each option takes 2 lines
        actual_index += 1  # Increment actual index for selectable items
    
    # Instructions at bottom with Left Arrow
    move_cursor(content_x + 5, content_height - 3)
    print(f"{Colors.DIM}‚Üë‚Üì navigate | enter select | ‚Üê/esc/q back to dev tools{Colors.RESET}")
    
    # Show quick tips if first time
    if not env_status['all_good']:
        move_cursor(content_x + 5, content_height - 5)
        print(f"{Colors.YELLOW}üí° Tip: Run Environment Check first to see what's missing{Colors.RESET}")

def start_web_both():
    """Start both backend and frontend servers with checks"""
    show_server_action("‚öîÔ∏è Firing Up The Entire Forge", Colors.GREEN)
    
    cols, lines = get_terminal_size()
    content_x = 27 + 4
    y = 5
    
    # Quick environment check
    env_status = check_environment_quick()
    
    if not env_status['all_good']:
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}‚ö† Environment issues detected:{Colors.RESET}")
        y += 2
        
        if not env_status['python']:
            move_cursor(content_x, y)
            print(f"{Colors.RED}‚úó Python not installed{Colors.RESET}")
            y += 1
        
        if not env_status['node']:
            move_cursor(content_x, y)
            print(f"{Colors.RED}‚úó Node.js not installed{Colors.RESET}")
            y += 1
        
        if not env_status['backend_initialized']:
            move_cursor(content_x, y)
            print(f"{Colors.YELLOW}‚ö† Backend not initialized{Colors.RESET}")
            y += 1
        
        if not env_status['frontend_initialized']:
            move_cursor(content_x, y)
            print(f"{Colors.YELLOW}‚ö† Frontend not initialized{Colors.RESET}")
            y += 1
        
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}Run Setup Wizard first to fix these issues.{Colors.RESET}")
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
        get_single_key()
        return
    
    # Check ports
    port_8000_ok, _ = check_port_available(8000)
    port_3000_ok, _ = check_port_available(3000)
    
    if not port_8000_ok or not port_3000_ok:
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}‚ö† Port conflicts detected:{Colors.RESET}")
        y += 2
        
        if not port_8000_ok:
            move_cursor(content_x, y)
            print(f"{Colors.RED}‚úó Port 8000 is already in use{Colors.RESET}")
            y += 1
        
        if not port_3000_ok:
            move_cursor(content_x, y)
            print(f"{Colors.RED}‚úó Port 3000 is already in use{Colors.RESET}")
            y += 1
        
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}Stop existing servers first.{Colors.RESET}")
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
        get_single_key()
        return
    
    # All checks passed - show launch screen
    move_cursor(content_x, y)
    print(f"{Colors.GREEN}‚úì All systems ready!{Colors.RESET}")
    y += 2
    
    move_cursor(content_x, y)
    print(f"{Colors.CYAN}Starting both servers:{Colors.RESET}")
    y += 1
    
    move_cursor(content_x + 2, y)
    print(f"{Colors.WHITE}‚Ä¢ Backend: http://localhost:8000{Colors.RESET}")
    y += 1
    move_cursor(content_x + 2, y)
    print(f"{Colors.WHITE}‚Ä¢ Frontend: http://localhost:3000{Colors.RESET}")
    y += 2
    
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}Starting Django backend...{Colors.RESET}")
    
    # Start backend
    backend_path = Path('/Users/berkhatirli/Desktop/unibos/backend')
    os.chdir(backend_path)
    activate_cmd = 'source venv/bin/activate' if platform.system() != 'Windows' else 'venv\\Scripts\\activate'
    backend_cmd = f"{activate_cmd} && python manage.py runserver"
    backend_process = subprocess.Popen(backend_cmd, shell=True)
    
    time.sleep(2)
    
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.GREEN}‚úì Backend started{Colors.RESET}")
    
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}Starting React frontend...{Colors.RESET}")
    
    # Start frontend
    frontend_path = Path('/Users/berkhatirli/Desktop/unibos/frontend')
    os.chdir(frontend_path)
    frontend_process = subprocess.Popen(['npm', 'start'])
    
    time.sleep(2)
    
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.GREEN}‚úì Frontend starting{Colors.RESET}")
    
    y += 2
    move_cursor(content_x, y)
    print(f"{Colors.GREEN}üî• Both servers are running!{Colors.RESET}")
    
    y += 2
    move_cursor(content_x, y)
    print(f"{Colors.CYAN}Backend: http://localhost:8000{Colors.RESET}")
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.CYAN}Frontend: http://localhost:3000{Colors.RESET}")
    
    y += 2
    move_cursor(content_x, y)
    print(f"{Colors.DIM}Use 'Stop All Servers' to stop both.{Colors.RESET}")
    
    y += 2
    move_cursor(content_x, y)
    print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
    get_single_key()

def show_web_status():
    """Enhanced server status with detailed information"""
    show_server_action("üìä Forge Status Report", Colors.BLUE)
    
    cols, lines = get_terminal_size()
    content_x = 27 + 4
    y = 5
    
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}Checking forge temperature...{Colors.RESET}")
    y += 2
    
    # Environment status
    env_status = check_environment_quick()
    move_cursor(content_x, y)
    print(f"{Colors.CYAN}Environment Status:{Colors.RESET}")
    y += 1
    
    # Python
    move_cursor(content_x + 2, y)
    icon = "‚úì" if env_status['python'] else "‚úó"
    color = Colors.GREEN if env_status['python'] else Colors.RED
    print(f"{color}{icon} Python{Colors.RESET}")
    y += 1
    
    # Node.js
    move_cursor(content_x + 2, y)
    icon = "‚úì" if env_status['node'] else "‚úó"
    color = Colors.GREEN if env_status['node'] else Colors.RED
    print(f"{color}{icon} Node.js{Colors.RESET}")
    y += 1
    
    # Backend initialized
    move_cursor(content_x + 2, y)
    icon = "‚úì" if env_status['backend_initialized'] else "‚úó"
    color = Colors.GREEN if env_status['backend_initialized'] else Colors.YELLOW
    status = "Initialized" if env_status['backend_initialized'] else "Not initialized"
    print(f"{color}{icon} Backend: {status}{Colors.RESET}")
    y += 1
    
    # Frontend initialized
    move_cursor(content_x + 2, y)
    icon = "‚úì" if env_status['frontend_initialized'] else "‚úó"
    color = Colors.GREEN if env_status['frontend_initialized'] else Colors.YELLOW
    status = "Initialized" if env_status['frontend_initialized'] else "Not initialized"
    print(f"{color}{icon} Frontend: {status}{Colors.RESET}")
    y += 2
    
    # Server status
    move_cursor(content_x, y)
    print(f"{Colors.CYAN}Server Status:{Colors.RESET}")
    y += 1
    
    # Check backend
    backend_running = False
    backend_pid = None
    try:
        result = subprocess.run("lsof -ti:8000", shell=True, capture_output=True, text=True)
        if result.stdout:
            backend_running = True
            backend_pid = result.stdout.strip()
    except:
        pass
    
    move_cursor(content_x + 2, y)
    if backend_running:
        print(f"{Colors.GREEN}‚úì Backend Server{Colors.RESET}")
        y += 1
        move_cursor(content_x + 4, y)
        print(f"{Colors.WHITE}Port:{Colors.RESET} {Colors.CYAN}8000{Colors.RESET}")
        y += 1
        move_cursor(content_x + 4, y)
        print(f"{Colors.WHITE}PID:{Colors.RESET} {Colors.CYAN}{backend_pid}{Colors.RESET}")
        y += 1
        move_cursor(content_x + 4, y)
        print(f"{Colors.WHITE}URL:{Colors.RESET} {Colors.BLUE}http://localhost:8000{Colors.RESET}")
    else:
        print(f"{Colors.GRAY}‚úó Backend Server: Not running{Colors.RESET}")
    y += 2
    
    # Check frontend
    frontend_running = False
    frontend_pid = None
    try:
        result = subprocess.run("lsof -ti:3000", shell=True, capture_output=True, text=True)
        if result.stdout:
            frontend_running = True
            frontend_pid = result.stdout.strip()
    except:
        pass
    
    move_cursor(content_x + 2, y)
    if frontend_running:
        print(f"{Colors.GREEN}‚úì Frontend Server{Colors.RESET}")
        y += 1
        move_cursor(content_x + 4, y)
        print(f"{Colors.WHITE}Port:{Colors.RESET} {Colors.CYAN}3000{Colors.RESET}")
        y += 1
        move_cursor(content_x + 4, y)
        print(f"{Colors.WHITE}PID:{Colors.RESET} {Colors.CYAN}{frontend_pid}{Colors.RESET}")
        y += 1
        move_cursor(content_x + 4, y)
        print(f"{Colors.WHITE}URL:{Colors.RESET} {Colors.BLUE}http://localhost:3000{Colors.RESET}")
    else:
        print(f"{Colors.GRAY}‚úó Frontend Server: Not running{Colors.RESET}")
    y += 2
    
    # Summary
    move_cursor(content_x, y)
    if backend_running and frontend_running:
        print(f"{Colors.GREEN}üî• The forge is fully operational!{Colors.RESET}")
    elif backend_running or frontend_running:
        print(f"{Colors.YELLOW}‚ö† The forge is partially operational{Colors.RESET}")
    else:
        print(f"{Colors.GRAY}üå´Ô∏è The forge is cold{Colors.RESET}")
    
    # Navigation instruction at bottom
    y = lines - 5
    move_cursor(content_x, y)
    separator_width = min(cols - content_x - 4, 60)
    print(f"{Colors.DIM}{'‚îÄ' * separator_width}{Colors.RESET}")
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.CYAN}‚Üê/Esc{Colors.DIM} Back to Web Forge Menu{Colors.RESET}")
    get_single_key()

def stop_all_web_servers():
    """Enhanced stop all servers with detailed feedback"""
    show_server_action("üõë Extinguishing the Forge", Colors.RED)
    
    cols, lines = get_terminal_size()
    content_x = 27 + 4
    y = 5
    
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}Checking for running servers...{Colors.RESET}")
    y += 2
    
    # Check and stop backend
    backend_pids = subprocess.run("lsof -ti:8000", shell=True, capture_output=True, text=True)
    if backend_pids.stdout:
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}Stopping backend server (PID: {backend_pids.stdout.strip()})...{Colors.RESET}")
        subprocess.run(["lsof", "-ti:8000", "|", "xargs", "kill", "-9"], shell=True, capture_output=True)
        y += 1
        move_cursor(content_x, y)
        print(f"{Colors.GREEN}‚úì Backend server stopped{Colors.RESET}")
    else:
        move_cursor(content_x, y)
        print(f"{Colors.GRAY}‚Ä¢ Backend server not running{Colors.RESET}")
    y += 2
    
    # Check and stop frontend
    frontend_pids = subprocess.run("lsof -ti:3000", shell=True, capture_output=True, text=True)
    if frontend_pids.stdout:
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}Stopping frontend server (PID: {frontend_pids.stdout.strip()})...{Colors.RESET}")
        subprocess.run(["lsof", "-ti:3000", "|", "xargs", "kill", "-9"], shell=True, capture_output=True)
        y += 1
        move_cursor(content_x, y)
        print(f"{Colors.GREEN}‚úì Frontend server stopped{Colors.RESET}")
    else:
        move_cursor(content_x, y)
        print(f"{Colors.GRAY}‚Ä¢ Frontend server not running{Colors.RESET}")
    y += 2
    
    # Summary
    move_cursor(content_x, y)
    if backend_pids.stdout or frontend_pids.stdout:
        print(f"{Colors.GREEN}‚úì All servers have been stopped{Colors.RESET}")
    else:
        print(f"{Colors.GRAY}No servers were running{Colors.RESET}")
    
    y += 2
    move_cursor(content_x, y)
    print(f"{Colors.DIM}The forge has been extinguished.{Colors.RESET}")
    
    y += 2
    move_cursor(content_x, y)
    print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
    get_single_key()

def check_environment_quick():
    """Quick environment check for status display"""
    env_status = {
        'python': False,
        'node': False,
        'npm': False,
        'backend_initialized': False,
        'frontend_initialized': False,
        'backend_venv': False,
        'all_good': False,
        'summary': ''
    }
    
    # Check Python
    try:
        result = subprocess.run(['python3', '--version'], capture_output=True, text=True)
        if result.returncode == 0:
            env_status['python'] = True
    except:
        pass
    
    # Check Node.js
    try:
        result = subprocess.run(['node', '--version'], capture_output=True, text=True)
        if result.returncode == 0:
            env_status['node'] = True
    except:
        pass
    
    # Check npm
    try:
        result = subprocess.run(['npm', '--version'], capture_output=True, text=True)
        if result.returncode == 0:
            env_status['npm'] = True
    except:
        pass
    
    # Check backend initialization
    backend_path = Path('/Users/berkhatirli/Desktop/unibos/backend')
    if (backend_path / 'manage.py').exists():
        env_status['backend_initialized'] = True
        if (backend_path / 'venv').exists() or (backend_path / '.venv').exists():
            env_status['backend_venv'] = True
    
    # Check frontend initialization
    frontend_path = Path('/Users/berkhatirli/Desktop/unibos/frontend')
    if (frontend_path / 'package.json').exists():
        env_status['frontend_initialized'] = True
        if (frontend_path / 'node_modules').exists():
            env_status['frontend_initialized'] = True
    
    # Summary
    missing = []
    if not env_status['python']:
        missing.append('Python')
    if not env_status['node']:
        missing.append('Node.js')
    if not env_status['npm']:
        missing.append('npm')
    
    if missing:
        env_status['summary'] = f"Missing: {', '.join(missing)}"
    elif not env_status['backend_initialized'] or not env_status['frontend_initialized']:
        env_status['summary'] = "Setup needed"
    else:
        env_status['all_good'] = True
        env_status['summary'] = "Ready"
    
    return env_status

def run_environment_check():
    """Detailed environment check with helpful messages"""
    show_server_action("üîç Environment Check", Colors.CYAN)
    
    cols, lines = get_terminal_size()
    content_x = 27 + 4  # Indented content
    y = 5
    
    # Add navigation hint at the top
    move_cursor(content_x, y)
    print(f"{Colors.DIM}‚Üê Press Left Arrow or ESC to go back{Colors.RESET}")
    y += 2
    
    checks = [
        ("Python 3.8+", check_python_version),
        ("Node.js 16+", check_node_version),
        ("npm/yarn", check_npm_version),
        ("PostgreSQL", check_postgresql),
        ("Redis", check_redis),
        ("Backend Dependencies", check_backend_deps),
        ("Frontend Dependencies", check_frontend_deps),
        ("Port 8000 Available", lambda: check_port_available(8000)),
        ("Port 3000 Available", lambda: check_port_available(3000)),
    ]
    
    all_passed = True
    
    for check_name, check_func in checks:
        if y < lines - 5:  # Leave space for footer
            move_cursor(content_x, y)
            print(f"{Colors.YELLOW}Checking {check_name}...{Colors.RESET}", end='', flush=True)
            
            result, message = check_func()
            
            move_cursor(content_x, y)
            if result:
                print(f"{Colors.GREEN}‚úì {check_name:<25} {message}{Colors.RESET}")
            else:
                print(f"{Colors.RED}‚úó {check_name:<25} {message}{Colors.RESET}")
                all_passed = False
            
            y += 1
    
    # Summary
    y += 1
    move_cursor(content_x, y)
    if all_passed:
        print(f"{Colors.GREEN}‚úì All checks passed! Your environment is ready.{Colors.RESET}")
    else:
        print(f"{Colors.YELLOW}‚ö† Some checks failed. Run Setup Wizard to fix issues.{Colors.RESET}")
    
    y += 2
    move_cursor(content_x, y)
    print(f"{Colors.DIM}Press any key to continue (‚Üê or ESC to go back)...{Colors.RESET}")
    
    # Handle navigation
    key = get_single_key()
    if key == '\x1b' or key == '\x1b[D':  # ESC or Left Arrow
        return  # Go back without clearing

def check_python_version():
    """Check if Python 3.8+ is installed"""
    try:
        result = subprocess.run(['python3', '--version'], capture_output=True, text=True)
        if result.returncode == 0:
            version = result.stdout.strip()
            # Extract version number
            import re
            match = re.search(r'(\d+)\.(\d+)', version)
            if match:
                major, minor = int(match.group(1)), int(match.group(2))
                if major >= 3 and minor >= 8:
                    return True, version
            return False, f"{version} (Need 3.8+)"
        return False, "Not installed"
    except:
        return False, "Not installed"

def check_node_version():
    """Check if Node.js 16+ is installed"""
    try:
        result = subprocess.run(['node', '--version'], capture_output=True, text=True)
        if result.returncode == 0:
            version = result.stdout.strip()
            # Extract version number
            import re
            match = re.search(r'v(\d+)\.', version)
            if match:
                major = int(match.group(1))
                if major >= 16:
                    return True, version
            return False, f"{version} (Need v16+)"
        return False, "Not installed"
    except:
        return False, "Not installed"

def check_npm_version():
    """Check if npm is installed"""
    try:
        result = subprocess.run(['npm', '--version'], capture_output=True, text=True)
        if result.returncode == 0:
            return True, f"v{result.stdout.strip()}"
        return False, "Not installed"
    except:
        return False, "Not installed"

def check_postgresql():
    """Check if PostgreSQL is available"""
    try:
        result = subprocess.run(['psql', '--version'], capture_output=True, text=True)
        if result.returncode == 0:
            return True, result.stdout.strip().split()[-1]
        return False, "Not installed"
    except:
        return False, "Not installed (optional)"

def check_redis():
    """Check if Redis is available"""
    try:
        result = subprocess.run(['redis-cli', '--version'], capture_output=True, text=True)
        if result.returncode == 0:
            version = result.stdout.strip().split()[1]
            return True, f"v{version}"
        return False, "Not installed"
    except:
        return False, "Not installed (optional)"

def check_backend_deps():
    """Check if backend dependencies are installed"""
    backend_path = Path('/Users/berkhatirli/Desktop/unibos/backend')
    venv_path = backend_path / 'venv'
    venv_alt_path = backend_path / '.venv'
    
    if not (backend_path / 'manage.py').exists():
        return False, "Backend not initialized"
    
    if venv_path.exists() or venv_alt_path.exists():
        return True, "Virtual environment found"
    
    return False, "No virtual environment"

def check_frontend_deps():
    """Check if frontend dependencies are installed"""
    frontend_path = Path('/Users/berkhatirli/Desktop/unibos/frontend')
    
    if not (frontend_path / 'package.json').exists():
        return False, "Frontend not initialized"
    
    if (frontend_path / 'node_modules').exists():
        return True, "Dependencies installed"
    
    return False, "Dependencies not installed"

def check_port_available(port):
    """Check if a port is available"""
    try:
        result = subprocess.run(f"lsof -ti:{port}", shell=True, capture_output=True)
        if result.returncode == 0 and result.stdout:
            return False, "In use"
        return True, "Available"
    except:
        return True, "Available"

def run_setup_wizard():
    """Interactive setup wizard for first-time users"""
    show_server_action("üßô Setup Wizard", Colors.MAGENTA, show_back_hint=True)
    
    cols, lines = get_terminal_size()
    content_x = 27 + 4
    y = 5
    
    # Welcome message
    move_cursor(content_x, y)
    print(f"{Colors.CYAN}Welcome to the UNIBOS Web Forge Setup Wizard!{Colors.RESET}")
    y += 2
    
    move_cursor(content_x, y)
    print(f"{Colors.WHITE}This wizard will help you set up:{Colors.RESET}")
    y += 1
    
    tasks = [
        "‚Ä¢ Backend environment (Django + PostgreSQL)",
        "‚Ä¢ Frontend environment (React + Node.js)",
        "‚Ä¢ Database configuration",
        "‚Ä¢ Initial project setup"
    ]
    
    for task in tasks:
        move_cursor(content_x + 2, y)
        print(f"{Colors.DIM}{task}{Colors.RESET}")
        y += 1
    
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}Continue with setup? (y/n/‚Üê): {Colors.RESET}", end='', flush=True)
    
    key = get_single_key()
    if not key or (key.lower() != 'y' if key else True) or key == '\x1b' or key == '\x1b[D':  # Not yes, ESC, or Left Arrow
        return
    
    # Setup steps
    setup_backend_environment()
    setup_frontend_environment()
    
    # Final message
    show_server_action("‚úÖ Setup Complete", Colors.GREEN)
    y = 5
    move_cursor(content_x, y)
    print(f"{Colors.GREEN}Setup completed successfully!{Colors.RESET}")
    y += 2
    
    move_cursor(content_x, y)
    print(f"{Colors.WHITE}You can now:{Colors.RESET}")
    y += 1
    
    next_steps = [
        "‚Ä¢ Start Backend Server (Django)",
        "‚Ä¢ Start Frontend Server (React)",
        "‚Ä¢ Or start both servers at once"
    ]
    
    for step in next_steps:
        move_cursor(content_x + 2, y)
        print(f"{Colors.CYAN}{step}{Colors.RESET}")
        y += 1
    
    y += 2
    move_cursor(content_x, y)
    print(f"{Colors.DIM}Press any key to continue...{Colors.RESET}")
    get_single_key()

def setup_backend_environment():
    """Setup backend Django environment"""
    cols, lines = get_terminal_size()
    content_x = 27 + 4
    y = 5
    
    clear_content_area()
    show_server_action("‚öôÔ∏è Setting Up Backend", Colors.BLUE)
    
    backend_path = Path('/Users/berkhatirli/Desktop/unibos/backend')
    
    # Check if backend directory exists
    if not backend_path.exists():
        move_cursor(content_x, y)
        print(f"{Colors.RED}Backend directory not found!{Colors.RESET}")
        return
    
    os.chdir(backend_path)
    
    # Create virtual environment
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}Creating Python virtual environment...{Colors.RESET}")
    
    result = subprocess.run(['python3', '-m', 'venv', 'venv'], capture_output=True)
    
    move_cursor(content_x, y)
    if result.returncode == 0:
        print(f"{Colors.GREEN}‚úì Virtual environment created{Colors.RESET}")
    else:
        print(f"{Colors.RED}‚úó Failed to create virtual environment{Colors.RESET}")
        return
    
    y += 1
    
    # Install dependencies
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}Installing backend dependencies...{Colors.RESET}")
    
    activate_cmd = 'source venv/bin/activate' if platform.system() != 'Windows' else 'venv\\Scripts\\activate'
    install_cmd = f"{activate_cmd} && pip install -r requirements.txt"
    
    result = subprocess.run(install_cmd, shell=True, capture_output=True)
    
    move_cursor(content_x, y)
    if result.returncode == 0:
        print(f"{Colors.GREEN}‚úì Dependencies installed{Colors.RESET}")
    else:
        print(f"{Colors.YELLOW}‚ö† Some dependencies may have failed{Colors.RESET}")
    
    y += 2
    move_cursor(content_x, y)
    print(f"{Colors.DIM}Backend setup complete. Database setup can be done separately.{Colors.RESET}")
    
    time.sleep(2)

def setup_frontend_environment():
    """Setup frontend React environment"""
    cols, lines = get_terminal_size()
    content_x = 27 + 4
    y = 5
    
    clear_content_area()
    show_server_action("üé® Setting Up Frontend", Colors.BLUE)
    
    frontend_path = Path('/Users/berkhatirli/Desktop/unibos/frontend')
    
    # Check if frontend directory exists
    if not frontend_path.exists():
        move_cursor(content_x, y)
        print(f"{Colors.RED}Frontend directory not found!{Colors.RESET}")
        return
    
    os.chdir(frontend_path)
    
    # Install dependencies
    move_cursor(content_x, y)
    print(f"{Colors.YELLOW}Installing frontend dependencies...{Colors.RESET}")
    print(f"{Colors.DIM}(This may take a few minutes){Colors.RESET}")
    
    result = subprocess.run(['npm', 'install'], capture_output=True)
    
    move_cursor(content_x, y)
    if result.returncode == 0:
        print(f"{Colors.GREEN}‚úì Dependencies installed successfully{Colors.RESET}")
    else:
        print(f"{Colors.YELLOW}‚ö† Some dependencies may have failed{Colors.RESET}")
        y += 1
        move_cursor(content_x, y)
        print(f"{Colors.DIM}Try running 'npm install' manually{Colors.RESET}")
    
    y += 2
    move_cursor(content_x, y)
    print(f"{Colors.DIM}Frontend setup complete.{Colors.RESET}")
    
    time.sleep(2)

def show_server_logs():
    """Show server logs in a formatted view"""
    show_server_action("üìú Server Logs", Colors.CYAN)
    
    cols, lines = get_terminal_size()
    content_x = 27 + 4
    y = 5
    
    # Log options
    move_cursor(content_x, y)
    print(f"{Colors.CYAN}Select log to view:{Colors.RESET}")
    y += 2
    
    log_options = [
        ("1", "Backend Server Log"),
        ("2", "Frontend Server Log"),
        ("3", "Backend Error Log"),
        ("4", "Frontend Build Log"),
        ("b", "Back to menu")
    ]
    
    for key, desc in log_options:
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}[{key}]{Colors.RESET} {desc}")
        y += 1
    
    y += 1
    move_cursor(content_x, y)
    print(f"{Colors.DIM}Select option: {Colors.RESET}", end='', flush=True)
    
    key = get_single_key()
    
    if key == '1':
        view_log_file('/Users/berkhatirli/Desktop/unibos/backend/server.log', 'Backend Server Log')
    elif key == '2':
        view_log_file('/Users/berkhatirli/Desktop/unibos/frontend/npm-debug.log', 'Frontend Server Log')
    elif key == '3':
        view_log_file('/Users/berkhatirli/Desktop/unibos/backend/error.log', 'Backend Error Log')
    elif key == '4':
        view_log_file('/Users/berkhatirli/Desktop/unibos/frontend/build.log', 'Frontend Build Log')

def view_log_file(log_path, title):
    """View a specific log file"""
    show_server_action(f"üìÑ {title}", Colors.CYAN)
    
    cols, lines = get_terminal_size()
    content_x = 27 + 4
    y = 5
    
    log_file = Path(log_path)
    
    if not log_file.exists():
        move_cursor(content_x, y)
        print(f"{Colors.YELLOW}Log file not found: {log_path}{Colors.RESET}")
        y += 2
        move_cursor(content_x, y)
        print(f"{Colors.DIM}The server may not have been started yet.{Colors.RESET}")
    else:
        # Read last N lines of log
        try:
            with open(log_file, 'r') as f:
                log_lines = f.readlines()[-20:]  # Last 20 lines
            
            for line in log_lines:
                if y < lines - 5:  # Leave space for footer
                    move_cursor(content_x, y)
                    # Truncate long lines
                    max_width = cols - content_x - 5
                    if len(line) > max_width:
                        line = line[:max_width-3] + "..."
                    print(f"{Colors.DIM}{line.rstrip()}{Colors.RESET}")
                    y += 1
        except Exception as e:
            move_cursor(content_x, y)
            print(f"{Colors.RED}Error reading log: {e}{Colors.RESET}")
    
    y = lines - 5
    move_cursor(content_x, y)
    print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
    get_single_key()

def clear_content_area():
    """Clear the content area"""
    cols, lines = get_terminal_size()
    content_x = 27  # Match main content area
    content_width = cols - content_x - 2
    
    # Start clearing from line 3 to avoid header overlap (header is lines 1-2)
    for y in range(3, lines - 1):
        move_cursor(content_x, y)
        print(' ' * content_width, end='')

def ai_builder_tools():
    """Launch AI Builder interface"""
    try:
        # Try the new AI Builder implementation
        try:
            from ai_builder import AIBuilder
            
            # Save current terminal state
            show_cursor()
            clear_screen()
            
            # Initialize and run AI Builder
            builder = AIBuilder()
            builder.run()
            
            # After AI Builder exits, properly restore screen
            clear_screen()
            hide_cursor()
            draw_main_screen()
            return
            
        except ImportError:
            # Fall back to legacy implementation
            pass
        
        # Legacy implementation
        from claude_cli import ClaudeCLI
        
        # Save current terminal state
        show_cursor()
        
        # Initialize and run claude CLI with menu
        claude = ClaudeCLI()
        claude.show_claude_tools_menu()
        
        # After claude exits, properly restore screen
        clear_screen()  # Clear any Claude residue
        hide_cursor()
        draw_main_screen()  # Redraw entire interface
        
    except ImportError as e:
        clear_screen()
        print(f"\n{Colors.RED}Error loading Claude CLI: {e}{Colors.RESET}")
        time.sleep(2)
        hide_cursor()
        draw_main_screen()
    except Exception as e:
        clear_screen()
        print(f"\n{Colors.RED}Error in Claude tools: {e}{Colors.RESET}")
        print(f"{Colors.DIM}Error type: {type(e).__name__}{Colors.RESET}")
        
        # More detailed error for debugging
        import traceback
        print(f"\n{Colors.DIM}Traceback:{Colors.RESET}")
        traceback.print_exc()
        
        time.sleep(5)
        hide_cursor()
        draw_main_screen()

def show_git_menu():
    """Launch git manager interface"""
    try:
        # Save terminal state
        show_cursor()
        clear_screen()
        
        from git_manager import GitManager
        git_manager = GitManager()
        git_manager.show_git_menu()
        
        # Restore terminal state
        hide_cursor()
        draw_main_screen()
        
    except ImportError as e:
        clear_screen()
        print(f"\n{Colors.RED}Error loading Git Manager: {e}{Colors.RESET}")
        time.sleep(2)
        hide_cursor()
        draw_main_screen()
    except Exception as e:
        clear_screen()
        print(f"\n{Colors.RED}Error in Git Manager: {e}{Colors.RESET}")
        time.sleep(2)
        hide_cursor()
        draw_main_screen()

def show_splash_screen():
    """Show animated splash screen"""
    clear_screen()
    cols, lines = get_terminal_size()
    
    # Get version info
    version = VERSION_INFO.get("version", "v236")
    
    # Claude Code style welcome message with box
    welcome_box = [
        f"{Colors.ORANGE}‚ï≠{'‚îÄ' * 24}‚ïÆ{Colors.RESET}",
        f"{Colors.ORANGE}‚îÇ{Colors.RESET} {Colors.BOLD}* welcome to unibos! *{Colors.RESET} {Colors.ORANGE}‚îÇ{Colors.RESET}",
        f"{Colors.ORANGE}‚ï∞{'‚îÄ' * 24}‚ïØ{Colors.RESET}"
    ]
    
    # ASCII art - Large and impressive unibos logo (3D Shadow Effect)
    logo_art = [
        f"",
        f"{Colors.ORANGE}‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó{Colors.RESET}",
        f"{Colors.ORANGE}‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù{Colors.RESET}",
        f"{Colors.ORANGE}‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó{Colors.RESET}",
        f"{Colors.ORANGE}‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë{Colors.RESET}",
        f"{Colors.ORANGE}‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë{Colors.RESET}",
        f"{Colors.ORANGE} ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù{Colors.RESET} {Colors.YELLOW}{version}{Colors.RESET}",
        f""
    ]
    
    # Calculate centering
    box_width = 26  # Updated to match new welcome box size
    logo_width = 48  # Width of the new impressive logo
    
    # Center the welcome box at top
    box_y = 4
    box_x = max(1, (cols - box_width) // 2)
    
    # Draw welcome box
    for i, line in enumerate(welcome_box):
        move_cursor(box_x, box_y + i)
        print(line)
    
    # Center the logo art
    logo_y = box_y + 6
    logo_x = max(1, (cols - logo_width) // 2)
    
    # Animate logo appearance
    for i, line in enumerate(logo_art):
        move_cursor(logo_x, logo_y + i)
        print(line, end='', flush=True)
        time.sleep(0.05)  # Smooth animation
    
    # Show additional info below
    info_y = logo_y + len(logo_art) + 2
    location = VERSION_INFO.get('location', 'bitez, bodrum, muƒüla, t√ºrkiye, d√ºnya, g√ºne≈ü sistemi, samanyolu, yerel galaksi grubu, evren')
    
    info_lines = [
        f"{Colors.DIM}unicorn bodrum operating system{Colors.RESET}",
        f"{Colors.DIM}build {VERSION_INFO.get('build', '20250801_1537')}{Colors.RESET}",
        f"",
        f"{Colors.DIM}by berk hatƒ±rlƒ±{Colors.RESET}",
        f"{Colors.DIM}{location}{Colors.RESET}"
    ]
    
    for i, line in enumerate(info_lines):
        # Adjust centering for longer location line
        if i == 4:  # Location line
            text_x = max(1, (cols - len(location)) // 2)
        else:
            text_x = max(1, (cols - 45) // 2)
        move_cursor(text_x, info_y + i)
        print(line)
    
    time.sleep(0.5)
    
    # Loading animation - positioned below the info
    loading_y = info_y + len(info_lines) + 2
    loading_text = "initializing system components..."
    loading_x = (cols - len(loading_text)) // 2
    
    # Show loading text
    move_cursor(loading_x, loading_y)
    print(f"{Colors.YELLOW}{loading_text}{Colors.RESET}")
    
    # Progress bar with wider design
    progress_y = loading_y + 2
    progress_width = 50  # Increased width
    progress_x = (cols - progress_width) // 2
    
    # Draw progress bar frame
    move_cursor(progress_x, progress_y)
    print(f"{Colors.DIM}[{' ' * (progress_width - 2)}]{Colors.RESET}")
    
    # Animate progress bar with varying speed
    for i in range(progress_width - 2):
        move_cursor(progress_x + 1 + i, progress_y)
        # Use different colors for different stages
        if i < (progress_width - 2) // 3:
            color = Colors.MAGENTA
        elif i < 2 * (progress_width - 2) // 3:
            color = Colors.YELLOW
        else:
            color = Colors.GREEN
        print(f"{color}‚ñà{Colors.RESET}", end='', flush=True)
        # Varying speed for more realistic loading
        if i % 5 == 0:
            time.sleep(0.03)
        else:
            time.sleep(0.01)
    
    # Keep the progress bar visible
    time.sleep(0.5)
    
    # Clear only the loading text
    move_cursor(loading_x - 2, loading_y)
    print(' ' * (len(loading_text) + 4), end='')
    
    # Show continue message below the progress bar
    continue_text = "press any key to continue..."
    continue_x = (cols - len(continue_text)) // 2
    continue_y = progress_y + 3  # 3 lines below progress bar
    move_cursor(continue_x, continue_y)
    print(f"{Colors.BLUE}{continue_text}{Colors.RESET}")
    
    # Wait for key press
    debug_mode = os.environ.get('UNIBOS_DEBUG', '').lower() == 'true'
    if debug_mode:
        with open('/tmp/unibos_debug.log', 'a') as f:
            f.write("splash screen: waiting for key press...\n")
    
    # Use simple key input for splash screen
    splash_key = get_simple_key()
    
    if debug_mode:
        with open('/tmp/unibos_debug.log', 'a') as f:
            f.write(f"splash screen: key pressed: {repr(splash_key)}\n")
    
    # Aggressive clear after splash screen
    if TERMIOS_AVAILABLE:
        try:
            import termios
            # Multiple flushes to ensure buffer is clear
            for _ in range(5):
                termios.tcflush(sys.stdin, termios.TCIFLUSH)
                termios.tcflush(sys.stdin, termios.TCIOFLUSH)
                time.sleep(0.01)
        except:
            pass

def main():
    """Main entry point"""
    try:
        # Ensure UTF-8 encoding for terminal
        if hasattr(sys.stdout, 'reconfigure'):
            sys.stdout.reconfigure(encoding='utf-8')
        if hasattr(sys.stderr, 'reconfigure'):
            sys.stderr.reconfigure(encoding='utf-8')
        
        # Set environment variable for UTF-8
        os.environ['PYTHONIOENCODING'] = 'utf-8'
        
        # Debug output
        if os.environ.get('UNIBOS_DEBUG') == 'true':
            print("DEBUG: Starting UNIBOS main()")
            print(f"DEBUG: Terminal size: {get_terminal_size()}")
            print(f"DEBUG: TERMIOS available: {TERMIOS_AVAILABLE}")
        
        # Show splash screen
        show_splash_screen()
        
        # Start main loop
        main_loop()
        
    except KeyboardInterrupt:
        if os.environ.get('UNIBOS_DEBUG') == 'true':
            print("\nDEBUG: KeyboardInterrupt caught")
        pass
    except Exception as e:
        print(f"\n{Colors.RED}Fatal error: {e}{Colors.RESET}")
        import traceback
        traceback.print_exc()
    finally:
        # Cleanup
        clear_screen()
        show_cursor()
        print(f"{Colors.GREEN}thank you for using unibos!{Colors.RESET}")
        print(f"{Colors.DIM}visit https://github.com/berkhatirli/unibos{Colors.RESET}\n")

if __name__ == "__main__":
    main()