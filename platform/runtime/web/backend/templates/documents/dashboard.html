{% extends 'web_ui/base.html' %}

{% block title %}documents - ocr & integration{% endblock %}

{% block header_title %}unibos{% endblock %}
{% block module_name %}documents - ocr & integration{% endblock %}

{% block content %}
<style>
    .documents-container {
        padding: 0;
        max-width: 100%;
        margin: 0;
    }

    .module-header {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        padding-bottom: 15px;
        border-bottom: 2px solid var(--orange);
        margin-bottom: 30px;
    }

    .module-header h1 {
        display: block;
        color: var(--orange);
        font-size: 24px;
        font-weight: bold;
        text-transform: lowercase;
        margin: 0;
        margin-bottom: 8px;
        line-height: 1.2;
    }

    .content-subtitle {
        display: block;
        font-size: 14px;
        color: var(--gray);
        text-transform: lowercase;
        margin: 0;
        line-height: 1.4;
    }

    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
    }

    .stat-card {
        background: rgba(20, 20, 20, 0.5);
        border: 1px solid #333;
        padding: 15px;
        border-radius: 4px;
        text-align: center;
    }

    .stat-value {
        font-size: 24px;
        color: var(--orange);
        font-weight: bold;
    }

    .stat-label {
        color: var(--gray);
        font-size: 12px;
        text-transform: lowercase;
        margin-top: 5px;
    }
    
    .upload-zone {
        background: var(--bg-dark);
        border: 2px dashed var(--orange);
        border-radius: 10px;
        padding: 40px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .upload-zone:hover {
        border-color: var(--orange-bright);
        background: rgba(255, 140, 0, 0.05);
    }
    
    .upload-zone.dragover {
        background: rgba(255, 140, 0, 0.1);
        border-color: var(--orange-bright);
    }
    
    .credit-card {
        background: linear-gradient(135deg, #ff8c00, #ff6600);
        border-radius: 10px;
        padding: 20px;
        color: #000;
        position: relative;
        min-height: 120px;
    }
    
    .card-number {
        font-size: 18px;
        letter-spacing: 2px;
        margin: 15px 0;
    }
    
    .card-info {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
    }
    
    .utilization-bar {
        background: rgba(0, 0, 0, 0.2);
        height: 8px;
        border-radius: 4px;
        margin-top: 10px;
        overflow: hidden;
    }
    
    .utilization-fill {
        background: #000;
        height: 100%;
        transition: width 0.3s;
    }
    
    .subscription-item {
        display: flex;
        align-items: center;
        padding: 10px;
        background: var(--bg-dark);
        border: 1px solid var(--dark-gray);
        border-radius: 5px;
        margin-bottom: 10px;
    }
    
    .subscription-icon {
        font-size: 24px;
        margin-right: 15px;
    }
    
    .subscription-info {
        flex: 1;
    }
    
    .subscription-name {
        color: var(--orange);
        font-weight: bold;
    }
    
    .subscription-amount {
        color: var(--cyan);
        font-weight: bold;
        text-align: right;
    }

    .content-box {
        background: rgba(20, 20, 20, 0.5);
        border: 1px solid #333;
        padding: 15px;
        border-radius: 4px;
        margin-bottom: 30px;
    }

    .content-title {
        color: var(--orange);
        font-size: 18px;
        text-transform: lowercase;
        margin: 0 0 15px 0;
    }

    .btn {
        padding: 8px 16px;
        background: transparent;
        color: var(--orange);
        border: 1px solid var(--orange);
        border-radius: 4px;
        cursor: pointer;
        text-transform: lowercase;
        transition: all 0.3s;
    }

    .btn:hover {
        background: var(--orange);
        color: #000;
        transform: translateY(-2px);
    }

    .btn-secondary {
        background: #000;
        color: var(--orange);
    }

    .file-list {
        margin-top: 20px;
    }

    .file-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        background: var(--bg-dark);
        border: 1px solid var(--dark-gray);
        border-radius: 4px;
        margin-bottom: 8px;
    }

    .file-info {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .file-icon {
        font-size: 24px;
    }

    .file-details {
        display: flex;
        flex-direction: column;
    }

    .file-name {
        color: var(--white);
        font-size: 14px;
    }

    .file-size {
        color: var(--gray);
        font-size: 12px;
    }

    .remove-btn {
        background: transparent;
        border: 1px solid var(--red);
        color: var(--red);
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        transition: all 0.3s;
    }

    .remove-btn:hover {
        background: var(--red);
        color: #000;
    }

    /* Fixed Upload Panel - Always visible at top */
    .upload-panel-fixed {
        position: fixed !important;
        top: 80px !important;
        right: 20px !important;
        width: 400px;
        max-width: 90vw;
        background: var(--bg-dark);
        border: 2px solid var(--orange);
        border-radius: 8px;
        padding: 20px;
        z-index: 99999 !important;
        display: none !important;
        max-height: 80vh;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        flex-direction: column;
    }

    .upload-panel-fixed.active {
        display: flex !important;
    }

    .upload-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--dark-gray);
    }

    .upload-panel-title {
        color: var(--orange);
        font-size: 16px;
        font-weight: bold;
    }

    .close-panel {
        background: transparent;
        border: none;
        color: var(--gray);
        font-size: 20px;
        cursor: pointer;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s;
    }

    .close-panel:hover {
        color: var(--red);
        transform: scale(1.2);
    }

    /* Progress Modal */
    .upload-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10000;
        align-items: center;
        justify-content: center;
    }

    .upload-modal.active {
        display: flex;
    }

    .modal-content {
        background: var(--bg-dark);
        border: 2px solid var(--orange);
        border-radius: 8px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
    }

    .modal-header {
        color: var(--orange);
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 20px;
        text-align: center;
    }

    .progress-container {
        margin: 20px 0;
    }

    .progress-bar-bg {
        background: rgba(255, 140, 0, 0.2);
        height: 30px;
        border-radius: 15px;
        overflow: hidden;
        position: relative;
    }

    .progress-bar-fill {
        background: linear-gradient(90deg, var(--orange), var(--orange-bright));
        height: 100%;
        width: 0%;
        transition: width 0.5s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #000;
        font-weight: bold;
        font-size: 12px;
    }

    .progress-text {
        text-align: center;
        color: var(--gray);
        margin-top: 10px;
        font-size: 14px;
    }

    .upload-status {
        margin: 20px 0;
        min-height: 60px;
        max-height: 300px;
        overflow-y: auto;
        padding-right: 10px;
    }

    .upload-status::-webkit-scrollbar {
        width: 8px;
    }

    .upload-status::-webkit-scrollbar-track {
        background: rgba(255, 140, 0, 0.1);
        border-radius: 4px;
    }

    .upload-status::-webkit-scrollbar-thumb {
        background: var(--orange);
        border-radius: 4px;
    }

    .upload-status::-webkit-scrollbar-thumb:hover {
        background: var(--orange-bright);
    }

    .status-item {
        padding: 8px;
        margin: 5px 0;
        border-radius: 4px;
        font-size: 13px;
    }

    .status-success {
        background: rgba(76, 175, 80, 0.1);
        border-left: 3px solid #4CAF50;
        color: #4CAF50;
    }

    .status-error {
        background: rgba(255, 68, 68, 0.1);
        border-left: 3px solid #ff4444;
        color: #ff4444;
    }

    .status-processing {
        background: rgba(255, 140, 0, 0.1);
        border-left: 3px solid var(--orange);
        color: var(--orange);
    }

    .modal-actions {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 20px;
    }

    .spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 140, 0, 0.3);
        border-radius: 50%;
        border-top-color: var(--orange);
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    /* Warning stat card for pending documents */
    .stat-card-warning {
        border: 2px solid var(--orange) !important;
        background: rgba(255, 140, 0, 0.05) !important;
    }

    .stat-card-warning .stat-value {
        color: var(--orange) !important;
        animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }

    /* Activity log scrollbar */
    #ocr-activity-log::-webkit-scrollbar {
        width: 6px;
    }

    #ocr-activity-log::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 3px;
    }

    #ocr-activity-log::-webkit-scrollbar-thumb {
        background: var(--orange);
        border-radius: 3px;
    }

    #ocr-activity-log::-webkit-scrollbar-thumb:hover {
        background: var(--orange-bright);
    }
</style>

<div class="module-header">
    <h1>üìÑ documents</h1>
    <p class="content-subtitle">evrak y√∂netimi ve ocr entegrasyonu</p>
</div>

<div class="content-box">
    <!-- Statistics -->
    <div class="stats-grid">
        <div class="stat-card" id="stat-total">
            <div class="stat-value">{{ total_documents }}</div>
            <div class="stat-label">total documents</div>
        </div>
        <div class="stat-card" id="stat-completed">
            <div class="stat-value">{{ processed_documents }}</div>
            <div class="stat-label">completed</div>
        </div>
        <div class="stat-card {% if processing_documents > 0 %}stat-card-warning{% endif %}" id="stat-processing">
            <div class="stat-value">{{ processing_documents }}</div>
            <div class="stat-label">processing now</div>
        </div>
        <div class="stat-card" id="stat-pending">
            <div class="stat-value">{{ pending_documents }}</div>
            <div class="stat-label">in queue</div>
        </div>
    </div>
</div>

<!-- active ocr processing notification -->
{% if processing_documents > 0 %}
<div class="content-box" id="ocr-processing-box" style="background: rgba(255, 140, 0, 0.1); border: 2px solid var(--orange);">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <div style="flex: 1;">
            <h3 style="color: var(--orange); margin: 0 0 8px 0;">
                <span id="ocr-status-icon">üîÑ</span>
                <span id="ocr-status-text">active ocr processing</span>
            </h3>
            <p style="color: var(--gray); margin: 0; font-size: 14px;">
                <strong style="color: var(--orange);">{{ processing_documents }}</strong> document(s) currently being processed with ocr in background.
                {% if pending_documents > 0 %}
                <br><span style="color: var(--gray);">+ {{ pending_documents }} document(s) waiting in queue</span>
                {% endif %}
            </p>
            {% if current_processing_doc %}
            <div id="current-processing-box" style="margin-top: 12px; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; border-left: 3px solid var(--orange); display: flex; gap: 12px; align-items: center;">
                {% if current_processing_doc.thumbnail_path %}
                <div style="flex-shrink: 0;">
                    <img id="current-processing-thumbnail" src="{{ current_processing_doc.thumbnail_path.url }}" alt="thumbnail" style="width: 80px; height: 80px; object-fit: cover; border-radius: 4px; border: 2px solid var(--orange);">
                </div>
                {% endif %}
                <div style="flex: 1;">
                    <div style="color: var(--white); font-size: 13px; font-weight: bold; margin-bottom: 4px;">currently processing:</div>
                    <div id="current-processing-filename" style="color: var(--cyan); font-size: 13px;">üìÑ {{ current_processing_doc.original_filename }}</div>
                    <div id="current-processing-uploaded" style="color: var(--gray); font-size: 11px; margin-top: 4px;">uploaded: {{ current_processing_doc.uploaded_at|date:"d M Y H:i" }}</div>
                </div>
            </div>
            {% endif %}

            <!-- Live Activity Log -->
            <div id="ocr-activity-log" style="margin-top: 12px; padding: 10px; background: rgba(0, 0, 0, 0.5); border-radius: 4px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 11px;">
                <div style="color: var(--orange); font-weight: bold; margin-bottom: 8px; font-family: sans-serif;">üìä activity log:</div>
                <div id="log-entries" style="color: var(--gray);">
                    <div class="log-entry" style="padding: 2px 0;">‚è≥ waiting for activity...</div>
                </div>
            </div>
        </div>
        <div style="display: flex; flex-direction: column; gap: 10px; align-items: flex-end; margin-left: 20px;">
            <div class="spinner" id="ocr-spinner"></div>
            <button id="ocr-pause-btn" class="btn" onclick="toggleOCRProcessing()" style="font-size: 12px; padding: 6px 12px; white-space: nowrap;">
                ‚è∏Ô∏è pause processing
            </button>
        </div>
    </div>
</div>
{% endif %}

<!-- pending queue notification (only show if no processing documents) -->
{% if pending_documents > 0 and processing_documents == 0 %}
<div class="content-box" style="background: rgba(100, 100, 100, 0.1); border: 2px solid var(--gray);">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <div style="flex: 1;">
            <h3 style="color: var(--gray); margin: 0 0 8px 0;">‚è∏Ô∏è processing queue</h3>
            <p style="color: var(--gray); margin: 0; font-size: 14px;">
                <strong style="color: var(--white);">{{ pending_documents }}</strong> document(s) waiting in queue for ocr processing.
                <br><span style="font-size: 12px;">background processor will start automatically.</span>
            </p>
        </div>
    </div>
</div>
{% endif %}

<!-- Upload Section -->
<div class="content-box">
    <h2 class="content-title">üì§ quick upload</h2>

    <div class="upload-zone" id="uploadZone">
        <div style="font-size: 48px; margin-bottom: 20px;">üìé</div>
        <div style="color: var(--orange); font-size: 18px; margin-bottom: 10px;">
            drag & drop files here
        </div>
        <div style="color: var(--gray); font-size: 14px;">
            or click to browse
        </div>
        <div style="color: var(--gray); font-size: 12px; margin-top: 10px;">
            supports: jpg, png, pdf ‚Ä¢ fast upload without ocr processing
        </div>
        <input type="file" id="fileInput" style="display: none;" multiple accept="image/*,application/pdf">
    </div>
</div>

<!-- Upload panel will be created dynamically by JavaScript and appended to body -->

<!-- Credit Cards -->
{% if credit_cards %}
<div class="content-box">
    <h2 class="content-title">üí≥ credit cards</h2>
    
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
        {% for card in credit_cards %}
        <div class="credit-card">
            <div style="font-weight: bold;">{{ card.bank_name }}</div>
            <div class="card-number">‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ {{ card.last_four_digits }}</div>
            <div class="card-info">
                <div>
                    <div style="font-size: 10px;">limit</div>
                    <div style="font-weight: bold;">‚Ç∫{{ card.credit_limit|floatformat:0 }}</div>
                </div>
                <div>
                    <div style="font-size: 10px;">available</div>
                    <div style="font-weight: bold;">‚Ç∫{{ card.available_credit|floatformat:0 }}</div>
                </div>
                <div>
                    <div style="font-size: 10px;">utilization</div>
                    <div style="font-weight: bold;">{{ card.utilization_rate|floatformat:0 }}%</div>
                </div>
            </div>
            <div class="utilization-bar">
                <div class="utilization-fill" style="width: {{ card.utilization_rate }}%;"></div>
            </div>
        </div>
        {% endfor %}
    </div>
    
    <div style="margin-top: 20px;">
        <button class="btn" onclick="window.location.href='{% url 'documents:credit_cards' %}'">
            manage cards
        </button>
    </div>
</div>
{% endif %}

<!-- Subscriptions -->
{% if subscriptions %}
<div class="content-box">
    <h2 class="content-title">üîÑ active subscriptions</h2>
    
    <div>
        {% for sub in subscriptions|slice:":5" %}
        <div class="subscription-item">
            <div class="subscription-icon">
                {% if 'netflix' in sub.service_name|lower %}üì∫
                {% elif 'spotify' in sub.service_name|lower %}üéµ
                {% elif 'youtube' in sub.service_name|lower %}üìπ
                {% elif 'amazon' in sub.service_name|lower %}üì¶
                {% elif 'apple' in sub.service_name|lower %}üçé
                {% else %}üì±{% endif %}
            </div>
            <div class="subscription-info">
                <div class="subscription-name">{{ sub.service_name }}</div>
                <div style="color: var(--gray); font-size: 12px;">
                    {{ sub.get_billing_cycle_display }} ‚Ä¢ next: {{ sub.next_billing_date|date:"d M" }}
                </div>
            </div>
            <div class="subscription-amount">
                ‚Ç∫{{ sub.amount|floatformat:0 }}
            </div>
        </div>
        {% endfor %}
    </div>
    
    <div style="margin-top: 20px;">
        <button class="btn" onclick="window.location.href='{% url 'documents:subscriptions' %}'">
            manage subscriptions
        </button>
    </div>
</div>
{% endif %}

<!-- Documents with Filters and Pagination -->
<div class="content-box">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <div style="display: flex; gap: 15px; align-items: center;">
            <h2 class="content-title" style="margin: 0;">üìÑ documents ({{ total_documents }} total)</h2>

            <!-- Items per page selector -->
            <div style="display: flex; align-items: center; gap: 8px;">
                <label style="color: var(--gray); font-size: 13px;">show:</label>
                <select id="perPageSelect" onchange="applyFilters()"
                        style="background: var(--bg-dark); color: var(--white); border: 1px solid var(--dark-gray); padding: 5px 8px; border-radius: 3px; font-size: 13px; cursor: pointer;">
                    <option value="10" {% if per_page == 10 %}selected{% endif %}>10</option>
                    <option value="20" {% if per_page == 20 or not per_page %}selected{% endif %}>20</option>
                    <option value="50" {% if per_page == 50 %}selected{% endif %}>50</option>
                    <option value="100" {% if per_page == 100 %}selected{% endif %}>100</option>
                    <option value="250" {% if per_page == 250 %}selected{% endif %}>250</option>
                </select>
            </div>
        </div>

        <div style="display: flex; gap: 10px; align-items: center;">
            <!-- Filters -->
            <div style="display: flex; gap: 10px;">
                <select id="typeFilter" onchange="applyFilters()"
                        style="background: var(--bg-dark); color: var(--white); border: 1px solid var(--dark-gray); padding: 5px; border-radius: 3px;">
                    <option value="">all types</option>
                    {% for value, label in document_types %}
                        <option value="{{ value }}" {% if current_type == value %}selected{% endif %}>
                            {{ label|lower }}
                        </option>
                    {% endfor %}
                </select>

                <select id="statusFilter" onchange="applyFilters()"
                        style="background: var(--bg-dark); color: var(--white); border: 1px solid var(--dark-gray); padding: 5px; border-radius: 3px;">
                    <option value="">all status</option>
                    {% for value, label in status_choices %}
                        <option value="{{ value }}" {% if current_status == value %}selected{% endif %}>
                            {{ label|lower }}
                        </option>
                    {% endfor %}
                </select>

                <input type="text" id="searchFilter" placeholder="search..." value="{{ current_search }}"
                       onkeyup="searchDebounced()"
                       style="background: var(--bg-dark); color: var(--white); border: 1px solid var(--dark-gray); padding: 5px; border-radius: 3px; width: 150px;">

                <button onclick="applyFilters()" class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;">üîç</button>

                {% if current_type or current_status or current_search %}
                    <button onclick="clearFilters()" class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;">‚úó clear</button>
                {% endif %}
            </div>
        </div>
    </div>
    
    <!-- Bulk Actions Bar -->
    <div id="bulkActionsBar" style="display: none; background: rgba(255, 140, 0, 0.1); border: 1px solid var(--orange); border-radius: 4px; padding: 15px; margin-bottom: 15px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="color: var(--orange); font-weight: bold;">
                <span id="selectedCount">0</span> document(s) selected
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="btn btn-secondary" onclick="deleteSelectedDocuments()" style="font-size: 12px; border-color: var(--red); color: var(--red);">
                    üóëÔ∏è delete selected
                </button>
                <button class="btn btn-secondary" onclick="clearSelection()" style="font-size: 12px;">
                    ‚úó clear selection
                </button>
            </div>
        </div>
    </div>

    <div id="documentsContainer">
    {% if documents %}
    <div style="overflow-x: auto;">
        <table style="width: 100%;">
            <thead>
                <tr style="border-bottom: 1px solid var(--dark-gray);">
                    <th style="text-align: left; padding: 10px; color: var(--orange); width: 40px;">
                        <input type="checkbox" id="selectAll" onclick="toggleSelectAll()" style="cursor: pointer;">
                    </th>
                    <th style="text-align: left; padding: 10px; color: var(--orange);">type</th>
                    <th style="text-align: left; padding: 10px; color: var(--orange);">filename</th>
                    <th style="text-align: left; padding: 10px; color: var(--orange);">store</th>
                    <th style="text-align: left; padding: 10px; color: var(--orange);">status</th>
                    <th style="text-align: left; padding: 10px; color: var(--orange);">confidence</th>
                    <th style="text-align: left; padding: 10px; color: var(--orange);">amount</th>
                    <th style="text-align: left; padding: 10px; color: var(--orange);">uploaded</th>
                </tr>
            </thead>
            <tbody>
                {% for doc in documents %}
                <tr style="border-bottom: 1px solid var(--dark-gray);" data-doc-id="{{ doc.id }}">
                    <td style="padding: 10px;" onclick="event.stopPropagation();">
                        <input type="checkbox" class="doc-checkbox" value="{{ doc.id }}" onchange="updateBulkActions()" style="cursor: pointer;">
                    </td>
                    <td style="padding: 10px; cursor: pointer;" onclick="window.location.href='{% url 'documents:document_detail' doc.id %}'">
                        {% if doc.document_type == 'receipt' %}üßæ
                        {% elif doc.document_type == 'invoice' %}üìë
                        {% elif doc.document_type == 'bank_statement' %}üè¶
                        {% else %}üìÑ{% endif %}
                        {{ doc.get_document_type_display }}
                    </td>
                    <td style="padding: 10px;">
                        <a href="{% url 'documents:document_detail' doc.id %}" style="color: var(--cyan); text-decoration: none;">
                            {{ doc.original_filename|truncatechars:30 }}
                        </a>
                    </td>
                    <td style="padding: 10px; color: var(--gray);">
                        {% if doc.parsed_receipt %}
                            {{ doc.parsed_receipt.store_name|default:"-" }}
                        {% else %}
                            -
                        {% endif %}
                    </td>
                    <td style="padding: 10px;">
                        {% if doc.processing_status == 'completed' %}
                            <span style="color: var(--green);">‚úì processed</span>
                        {% elif doc.processing_status == 'pending' %}
                            <span style="color: var(--yellow);">‚è≥ pending</span>
                        {% elif doc.processing_status == 'failed' %}
                            <span style="color: var(--red);">‚úó failed</span>
                        {% else %}
                            <span style="color: var(--gray);">{{ doc.get_processing_status_display }}</span>
                        {% endif %}
                    </td>
                    <td style="padding: 10px;">
                        {% if doc.ocr_confidence %}
                            <span style="color: {% if doc.ocr_confidence > 80 %}var(--green){% elif doc.ocr_confidence > 50 %}var(--yellow){% else %}var(--red){% endif %};">
                                {{ doc.ocr_confidence|floatformat:0 }}%
                            </span>
                        {% else %}
                            <span style="color: var(--gray);">-</span>
                        {% endif %}
                    </td>
                    <td style="padding: 10px;">
                        {% if doc.parsed_receipt and doc.parsed_receipt.total_amount %}
                            <span style="color: var(--orange); font-weight: bold;">
                                ‚Ç∫{{ doc.parsed_receipt.total_amount|floatformat:2 }}
                            </span>
                        {% else %}
                            <span style="color: var(--gray);">-</span>
                        {% endif %}
                    </td>
                    <td style="padding: 10px; color: var(--gray);">{{ doc.uploaded_at|date:"d M H:i" }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    
    <!-- Pagination -->
    {% if page_obj.has_other_pages %}
    <div style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 20px;">
        {% if page_obj.has_previous %}
            <button onclick="loadPage(1)" class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;">¬´ first</button>
            <button onclick="loadPage({{ page_obj.previous_page_number }})" class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;">‚Äπ prev</button>
        {% endif %}

        <span style="color: var(--orange);">
            page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}
        </span>

        {% if page_obj.has_next %}
            <button onclick="loadPage({{ page_obj.next_page_number }})" class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;">next ‚Ä∫</button>
            <button onclick="loadPage({{ page_obj.paginator.num_pages }})" class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;">last ¬ª</button>
        {% endif %}
    </div>
    {% endif %}

    {% else %}
    <div style="text-align: center; padding: 40px; color: var(--gray);">
        <div style="font-size: 48px; margin-bottom: 10px;">üìÑ</div>
        <div>no documents found</div>
        {% if current_type or current_status or current_search %}
            <div style="margin-top: 10px;">
                <button onclick="clearFilters()" style="color: var(--orange); background: none; border: none; cursor: pointer; text-decoration: underline;">clear filters</button>
            </div>
        {% endif %}
    </div>
    {% endif %}
    </div>
</div>

<!-- Quick Actions -->
<div class="content-box">
    <h2 class="content-title">‚ö° quick actions</h2>

    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <button class="btn" onclick="window.location.href='{% url 'documents:upload' %}'">
            üì§ batch upload & process
        </button>
        <button class="btn" onclick="window.location.href='{% url 'documents:recycle_bin' %}'">
            üóëÔ∏è recycle bin
        </button>
        <button class="btn" onclick="window.location.href='{% url 'documents:credit_cards' %}'">
            üí≥ credit cards
        </button>
        <button class="btn" onclick="window.location.href='{% url 'documents:subscriptions' %}'">
            üîÑ subscriptions
        </button>
    </div>
</div>

<!-- Upload modal will be created dynamically by JavaScript and appended to body -->


<script>
// Upload functionality
let selectedFiles = [];
let uploadZone;
let fileInput;

// Initialize everything when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Get DOM elements
    uploadZone = document.getElementById('uploadZone');
    fileInput = document.getElementById('fileInput');

    // Setup event listeners
    uploadZone.addEventListener('click', () => {
        fileInput.click();
    });

    uploadZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadZone.classList.add('dragover');
    });

    uploadZone.addEventListener('dragleave', () => {
        uploadZone.classList.remove('dragover');
    });

    uploadZone.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadZone.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
    });

    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
            handleFiles(e.target.files);
        }
    });
    // Create Upload Panel
    const uploadPanel = document.createElement('div');
    uploadPanel.id = 'uploadPanel';
    uploadPanel.className = 'upload-panel-fixed';
    uploadPanel.innerHTML = `
        <div class="upload-panel-header">
            <div class="upload-panel-title">üì§ selected files (<span id="fileCount">0</span>)</div>
            <button class="close-panel" onclick="closeUploadPanel()">‚úï</button>
        </div>
        <div id="fileItems" style="margin-bottom: 15px; max-height: calc(80vh - 180px); overflow-y: auto;"></div>
        <div style="display: flex; gap: 10px; flex-direction: column; border-top: 1px solid var(--dark-gray); padding-top: 15px;">
            <button class="btn" id="uploadBtn" onclick="uploadFiles()" style="width: 100%;">
                üì§ upload files
            </button>
            <button class="btn btn-secondary" id="clearBtn" onclick="clearFiles()" style="width: 100%;">
                üóëÔ∏è clear all
            </button>
        </div>
    `;
    document.body.appendChild(uploadPanel);

    // Create Upload Modal
    const uploadModal = document.createElement('div');
    uploadModal.id = 'uploadModal';
    uploadModal.className = 'upload-modal';
    uploadModal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <span id="modalTitle">üì§ uploading files...</span>
            </div>
            <div class="progress-container">
                <div class="progress-bar-bg">
                    <div id="progressBarFill" class="progress-bar-fill">0%</div>
                </div>
                <div id="progressText" class="progress-text">preparing upload...</div>
            </div>
            <div id="uploadStatus" class="upload-status"></div>
            <div class="modal-actions" id="modalActions" style="display: none;">
                <button class="btn" onclick="closeModal()">close</button>
                <button class="btn btn-secondary" onclick="window.location.reload()">refresh page</button>
            </div>
        </div>
    `;
    document.body.appendChild(uploadModal);
});

function handleFiles(files) {
    selectedFiles = Array.from(files);
    displayFiles();
}

function displayFiles() {
    const uploadPanel = document.getElementById('uploadPanel');

    if (selectedFiles.length === 0) {
        uploadPanel.classList.remove('active');
        return;
    }

    // Show fixed panel on top-right
    uploadPanel.classList.add('active');
    document.getElementById('fileCount').textContent = selectedFiles.length;

    const fileItems = document.getElementById('fileItems');
    fileItems.innerHTML = '';

    selectedFiles.forEach((file, index) => {
        const fileSize = (file.size / 1024).toFixed(1) + ' KB';
        const fileIcon = file.type.includes('pdf') ? 'üìë' : 'üñºÔ∏è';

        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.innerHTML = `
            <div class="file-info">
                <div class="file-icon">${fileIcon}</div>
                <div class="file-details">
                    <div class="file-name">${file.name}</div>
                    <div class="file-size">${fileSize}</div>
                </div>
            </div>
            <button class="remove-btn" onclick="removeFile(${index})">‚úï</button>
        `;
        fileItems.appendChild(fileItem);
    });
}

function removeFile(index) {
    selectedFiles.splice(index, 1);
    displayFiles();
}

function closeUploadPanel() {
    clearFiles();
}

function clearFiles() {
    selectedFiles = [];
    fileInput.value = '';
    displayFiles();
}

async function uploadFiles() {
    if (selectedFiles.length === 0) return;

    // Save files before closing panel (which clears selectedFiles)
    const filesToUpload = [...selectedFiles];

    // Hide upload panel and show modal
    const uploadPanel = document.getElementById('uploadPanel');
    uploadPanel.classList.remove('active');
    showUploadModal();

    const CHUNK_SIZE = 10; // Upload 10 files at a time (faster now that we skip OCR)
    const totalFiles = filesToUpload.length;
    let uploadedFiles = 0;
    let failedFiles = 0;
    const allErrors = [];

    // Split files into chunks
    const chunks = [];
    for (let i = 0; i < filesToUpload.length; i += CHUNK_SIZE) {
        chunks.push(filesToUpload.slice(i, i + CHUNK_SIZE));
    }

    // Upload each chunk sequentially
    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
        const chunk = chunks[chunkIndex];
        const chunkNumber = chunkIndex + 1;

        updateProgress(
            Math.round((chunkIndex / chunks.length) * 90),
            `uploading chunk ${chunkNumber}/${chunks.length} (${chunk.length} files)...`
        );

        // Add status message for current chunk
        addStatusMessage(
            `üì§ uploading chunk ${chunkNumber}/${chunks.length}: ${chunk.length} files`,
            'processing'
        );

        try {
            const formData = new FormData();
            chunk.forEach(file => {
                formData.append('files', file);
            });
            formData.append('document_type', 'unknown');  // Let OCR detect type
            formData.append('batch_name', `Quick Upload ${new Date().toLocaleString('tr-TR')} - Chunk ${chunkNumber}`);
            formData.append('upload_only', 'true');  // CRITICAL: Skip OCR processing

            const response = await fetch('{% url "documents:upload" %}', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });

            if (response.ok) {
                const data = await response.json();

                // Count uploaded files (not processed!)
                uploadedFiles += data.uploaded || 0;
                failedFiles += data.failed || 0;

                if (data.errors && data.errors.length > 0) {
                    allErrors.push(...data.errors);
                }

                // Update status for successful chunk
                addStatusMessage(
                    `‚úì chunk ${chunkNumber} uploaded: ${data.uploaded}/${chunk.length} files saved`,
                    'success'
                );
            } else {
                const errorText = await response.text();
                console.error('Upload failed:', response.status, errorText);
                failedFiles += chunk.length;
                addStatusMessage(
                    `‚úó chunk ${chunkNumber} failed: server error ${response.status}`,
                    'error'
                );
                allErrors.push(`Chunk ${chunkNumber} failed with status ${response.status}`);
            }
        } catch (error) {
            console.error('Chunk upload error:', error);
            console.error('Error stack:', error.stack);
            failedFiles += chunk.length;
            addStatusMessage(
                `‚úó chunk ${chunkNumber} failed: ${error.message}`,
                'error'
            );
            allErrors.push(`Chunk ${chunkNumber}: ${error.message}`);
        }

        // Small delay between chunks
        if (chunkIndex < chunks.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 300));
        }
    }

    // Final processing
    updateProgress(100, 'upload complete!');

    // Clear selected files
    clearFiles();

    // Show final results
    const response = {
        success: uploadedFiles > 0,
        total: totalFiles,
        uploaded: uploadedFiles,
        failed: failedFiles,
        errors: allErrors
    };

    handleUploadResponse(response);
}

function showUploadModal() {
    const modal = document.getElementById('uploadModal');
    modal.classList.add('active');
    document.getElementById('progressBarFill').style.width = '0%';
    document.getElementById('progressBarFill').textContent = '0%';
    document.getElementById('progressText').textContent = 'preparing upload...';
    document.getElementById('uploadStatus').innerHTML = '';
    document.getElementById('modalActions').style.display = 'none';
}

function updateProgress(percent, message) {
    const fill = document.getElementById('progressBarFill');
    fill.style.width = percent + '%';
    fill.textContent = percent + '%';
    document.getElementById('progressText').textContent = message;
}

function addStatusMessage(message, type) {
    const statusDiv = document.getElementById('uploadStatus');
    const statusItem = document.createElement('div');
    statusItem.className = `status-item status-${type}`;
    statusItem.textContent = message;
    statusDiv.appendChild(statusItem);

    // Auto-scroll to bottom to show latest message
    statusDiv.scrollTop = statusDiv.scrollHeight;
}

function handleUploadResponse(response) {
    // Show results (already at 100% from chunk processing)
    if (response.success) {
        document.getElementById('modalTitle').innerHTML = '‚úÖ upload successful';

        // add summary message (uploaded, ocr processing in background!)
        if (response.failed === 0) {
            addStatusMessage(`üéâ all ${response.total} file(s) uploaded successfully!`, 'success');
            addStatusMessage(`üîÑ ocr processing started in background - page will refresh when complete`, 'processing');
        } else {
            addStatusMessage(`‚úì uploaded ${response.uploaded} of ${response.total} file(s)`, 'success');
            addStatusMessage(`‚ö† ${response.failed} file(s) failed to upload`, 'error');
            addStatusMessage(`üîÑ successful uploads are being processed with ocr in background`, 'processing');
        }

        // Show errors if any (limited to avoid overwhelming UI)
        if (response.errors && response.errors.length > 0) {
            const maxErrors = 10;
            response.errors.slice(0, maxErrors).forEach(error => {
                addStatusMessage(`‚úó ${error}`, 'error');
            });

            if (response.errors.length > maxErrors) {
                addStatusMessage(`... and ${response.errors.length - maxErrors} more errors`, 'error');
            }
        }
    } else {
        document.getElementById('modalTitle').innerHTML = '‚ùå upload failed';
        addStatusMessage(response.error || 'no files were uploaded successfully', 'error');
    }

    // Show action buttons
    document.getElementById('modalActions').style.display = 'flex';

    // Auto-reload after 3 seconds if all successful
    if (response.success && response.failed === 0) {
        let countdown = 3;
        const countdownInterval = setInterval(() => {
            document.getElementById('progressText').textContent = `page will reload in ${countdown} seconds...`;
            countdown--;

            if (countdown < 0) {
                clearInterval(countdownInterval);
                window.location.reload();
            }
        }, 1000);
    }
}

function handleUploadError(errorMessage) {
    updateProgress(0, 'upload failed');
    document.getElementById('modalTitle').innerHTML = '‚ùå upload failed';
    addStatusMessage(errorMessage, 'error');
    document.getElementById('modalActions').style.display = 'flex';

    // Re-enable upload button
    const uploadBtn = document.getElementById('uploadBtn');
    if (uploadBtn) {
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'üì§ upload files';
    }
}

function closeModal() {
    const modal = document.getElementById('uploadModal');
    modal.classList.remove('active');

    // Reset file selection
    clearFiles();
}

// Bulk Actions Functions
function toggleSelectAll() {
    const selectAll = document.getElementById('selectAll');
    const checkboxes = document.querySelectorAll('.doc-checkbox');
    checkboxes.forEach(cb => cb.checked = selectAll.checked);
    updateBulkActions();
}

function updateBulkActions() {
    const checkboxes = document.querySelectorAll('.doc-checkbox:checked');
    const bulkBar = document.getElementById('bulkActionsBar');
    const selectedCount = document.getElementById('selectedCount');

    selectedCount.textContent = checkboxes.length;
    bulkBar.style.display = checkboxes.length > 0 ? 'block' : 'none';

    // Update select all checkbox state
    const allCheckboxes = document.querySelectorAll('.doc-checkbox');
    const selectAll = document.getElementById('selectAll');
    selectAll.checked = checkboxes.length === allCheckboxes.length && allCheckboxes.length > 0;
}

function clearSelection() {
    document.querySelectorAll('.doc-checkbox').forEach(cb => cb.checked = false);
    document.getElementById('selectAll').checked = false;
    updateBulkActions();
}

function getSelectedDocumentIds() {
    const checkboxes = document.querySelectorAll('.doc-checkbox:checked');
    return Array.from(checkboxes).map(cb => cb.value);
}

async function deleteSelectedDocuments() {
    const ids = getSelectedDocumentIds();
    if (ids.length === 0) return;

    if (!confirm(`delete ${ids.length} document(s)? they will be moved to recycle bin.`)) return;

    // Store the IDs before making the request
    const idsToDelete = [...ids];

    try {
        const response = await fetch('{% url "documents:bulk_delete" %}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify({ document_ids: idsToDelete })
        });

        if (response.ok) {
            const data = await response.json();

            // Immediately update stat cards
            const totalCard = document.getElementById('stat-total');
            if (totalCard) {
                const valueElement = totalCard.querySelector('.stat-value');
                const currentTotal = parseInt(valueElement.textContent);
                const newTotal = currentTotal - data.deleted;
                valueElement.textContent = newTotal;
                // Flash effect
                totalCard.style.transition = 'background-color 0.3s';
                totalCard.style.backgroundColor = 'rgba(255, 140, 0, 0.2)';
                setTimeout(() => totalCard.style.backgroundColor = '', 500);
            }

            // Remove deleted rows from DOM with animation
            idsToDelete.forEach(id => {
                const row = document.querySelector(`tr[data-doc-id="${id}"]`);
                if (row) {
                    row.style.transition = 'opacity 0.3s, transform 0.3s';
                    row.style.opacity = '0';
                    row.style.transform = 'translateX(-20px)';
                    setTimeout(() => row.remove(), 300);
                }
            });

            // Clear selection and update UI
            setTimeout(() => {
                clearSelection();

                // Check if there are any rows left
                const remainingRows = document.querySelectorAll('tbody tr').length;

                if (remainingRows === idsToDelete.length) {
                    // All visible rows were deleted, reload to show next page or empty state
                    window.location.reload();
                } else {
                    // Manually trigger status update to refresh all stats
                    updateProcessingStatus();
                    console.log(`Successfully deleted ${data.deleted} document(s)`);
                }
            }, 350);
        } else {
            alert('failed to delete documents. please try again.');
        }
    } catch (error) {
        alert(`error: ${error.message}`);
    }
}

// Live status updates via polling
let statusPollInterval = null;

function startStatusPolling() {
    // Only poll if we have processing or pending documents
    const processingCount = {{ processing_documents|default:0 }};
    const pendingCount = {{ pending_documents|default:0 }};

    if (processingCount > 0 || pendingCount > 0) {
        // Poll every 3 seconds
        statusPollInterval = setInterval(updateProcessingStatus, 3000);
        console.log('Started status polling');
    }
}

// Track previous stats to detect changes
let previousStats = null;

async function updateProcessingStatus() {
    try {
        const response = await fetch('{% url "documents:api_processing_status" %}');
        if (!response.ok) return;

        const data = await response.json();
        if (!data.success) return;

        // Update stat cards
        const stats = data.stats;
        updateStatCard('total documents', stats.total);
        updateStatCard('completed', stats.completed);
        updateStatCard('processing now', stats.processing);
        updateStatCard('in queue', stats.pending);

        // Check if processing or pending count changed (documents finished processing)
        if (previousStats) {
            const processingDecreased = stats.processing < previousStats.processing;
            const pendingDecreased = stats.pending < previousStats.pending;
            const processingIncreased = stats.processing > previousStats.processing;

            // If documents finished processing, refresh the list to remove them from view
            if (processingDecreased || pendingDecreased) {
                const completedCount = previousStats.processing - stats.processing;
                if (completedCount > 0) {
                    addLogEntry(`${completedCount} document(s) completed OCR processing`, 'success');
                }
                console.log('Documents finished processing, refreshing list...');
                applyFilters(1);
            }

            // If new documents started processing
            if (processingIncreased) {
                const newCount = stats.processing - previousStats.processing;
                addLogEntry(`${newCount} new document(s) started processing`, 'info');
            }
        }

        // Store current stats for next comparison
        previousStats = { ...stats };

        // Update current processing display and log doc changes
        const currentDoc = data.current_processing;
        if (currentDoc) {
            // Check if we moved to a new document
            if (previousDocId && previousDocId !== currentDoc.id) {
                addLogEntry(`Started processing: ${currentDoc.filename}`, 'info');
                previousDocId = currentDoc.id;
            } else if (!previousDocId) {
                addLogEntry(`Processing: ${currentDoc.filename}`, 'info');
                previousDocId = currentDoc.id;
            }
        } else if (previousDocId) {
            // Document finished
            previousDocId = null;
        }

        updateCurrentProcessing(currentDoc, stats.processing, stats.pending);

        // Log queue status periodically (every 10 polls = ~30 seconds)
        if (stats.pending > 0 && Math.random() < 0.1) {
            addLogEntry(`${stats.pending} document(s) waiting in queue`, 'info');
        }

        // If no more processing/pending, stop polling and refresh
        if (stats.processing === 0 && stats.pending === 0) {
            clearInterval(statusPollInterval);
            addLogEntry('All documents processed! Page will reload...', 'success');
            console.log('All processing complete, reloading page...');
            setTimeout(() => window.location.reload(), 1000);
        }

    } catch (error) {
        console.error('Status update failed:', error);
        addLogEntry('Failed to fetch status update', 'error');
    }
}

function updateStatCard(label, value) {
    // Map label to stat card ID
    const labelToId = {
        'total documents': 'stat-total',
        'completed': 'stat-completed',
        'processing now': 'stat-processing',
        'in queue': 'stat-pending'
    };

    const cardId = labelToId[label];
    if (!cardId) return;

    const card = document.getElementById(cardId);
    if (!card) return;

    const valueElement = card.querySelector('.stat-value');
    if (valueElement && valueElement.textContent != value) {
        valueElement.textContent = value;
        // Add flash effect
        card.style.transition = 'background-color 0.3s';
        card.style.backgroundColor = 'rgba(255, 140, 0, 0.2)';
        setTimeout(() => card.style.backgroundColor = '', 500);
    }
}

function updateCurrentProcessing(currentDoc, processingCount, pendingCount) {
    if (processingCount > 0 && currentDoc) {
        // Update thumbnail if available
        const thumbnailEl = document.getElementById('current-processing-thumbnail');
        if (thumbnailEl && currentDoc.thumbnail_url) {
            thumbnailEl.src = currentDoc.thumbnail_url;
        }

        // Update filename
        const filenameEl = document.getElementById('current-processing-filename');
        if (filenameEl) {
            filenameEl.textContent = `üìÑ ${currentDoc.filename}`;
        }

        // Update uploaded date
        const uploadedEl = document.getElementById('current-processing-uploaded');
        if (uploadedEl) {
            uploadedEl.textContent = `uploaded: ${currentDoc.uploaded_at}`;
        }

        // Update processing count
        const processingBox = document.querySelector('[style*="rgba(255, 140, 0, 0.1)"]');
        if (processingBox) {
            const countEl = processingBox.querySelector('strong[style*="color: var(--orange)"]');
            if (countEl) {
                countEl.textContent = processingCount;
            }

            // Update pending count if exists
            const pendingSpan = processingBox.querySelector('span[style*="color: var(--gray)"]');
            if (pendingSpan && pendingCount > 0) {
                pendingSpan.textContent = `+ ${pendingCount} document(s) waiting in queue`;
            }
        }
    }
}

// Start polling when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Add initial log entry
    const processingCount = {{ processing_documents|default:0 }};
    const pendingCount = {{ pending_documents|default:0 }};

    if (processingCount > 0 || pendingCount > 0) {
        addLogEntry('Page loaded - monitoring OCR processing', 'info');
        if (processingCount > 0) {
            addLogEntry(`${processingCount} document(s) currently processing`, 'info');
        }
        if (pendingCount > 0) {
            addLogEntry(`${pendingCount} document(s) waiting in queue`, 'info');
        }
    }

    startStatusPolling();

    // Restore per_page preference from localStorage
    const savedPerPage = localStorage.getItem('documents_per_page');
    const perPageSelect = document.getElementById('perPageSelect');

    if (savedPerPage && perPageSelect) {
        // Check if current URL already has per_page parameter
        const urlParams = new URLSearchParams(window.location.search);
        const urlPerPage = urlParams.get('per_page');

        // If URL doesn't have per_page but localStorage does, set it
        if (!urlPerPage) {
            perPageSelect.value = savedPerPage;
            // If it's not the default (20), apply the filter to update the URL
            if (savedPerPage !== '20') {
                applyFilters(1);
            }
        }
    }
});

// ===== AJAX Filtering and Pagination =====
let searchTimeout;

function applyFilters(page = 1) {
    const typeFilter = document.getElementById('typeFilter').value;
    const statusFilter = document.getElementById('statusFilter').value;
    const searchFilter = document.getElementById('searchFilter').value;
    const perPage = document.getElementById('perPageSelect').value;

    // Save per_page preference to localStorage
    if (perPage) {
        localStorage.setItem('documents_per_page', perPage);
    }

    // Build query string
    const params = new URLSearchParams();
    if (typeFilter) params.append('type', typeFilter);
    if (statusFilter) params.append('status', statusFilter);
    if (searchFilter) params.append('search', searchFilter);
    if (perPage) params.append('per_page', perPage);
    if (page > 1) params.append('page', page);

    // Show loading state
    const container = document.getElementById('documentsContainer');
    container.style.opacity = '0.5';
    container.style.pointerEvents = 'none';

    // Fetch filtered results
    fetch(`?${params.toString()}`, {
        headers: {
            'X-Requested-With': 'XMLHttpRequest'
        }
    })
    .then(response => response.text())
    .then(html => {
        // Parse the response and extract the documents container
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const newContainer = doc.getElementById('documentsContainer');

        if (newContainer) {
            container.innerHTML = newContainer.innerHTML;
        }

        // Update filter selects from the new HTML to keep them in sync
        const newTypeFilter = doc.getElementById('typeFilter');
        const newStatusFilter = doc.getElementById('statusFilter');
        const newPerPageSelect = doc.getElementById('perPageSelect');

        if (newTypeFilter) {
            document.getElementById('typeFilter').value = newTypeFilter.value;
        }
        if (newStatusFilter) {
            document.getElementById('statusFilter').value = newStatusFilter.value;
        }
        if (newPerPageSelect) {
            document.getElementById('perPageSelect').value = newPerPageSelect.value;
        }

        // Update URL without reloading
        const newUrl = `${window.location.pathname}${params.toString() ? '?' + params.toString() : ''}`;
        window.history.pushState({}, '', newUrl);

        // Restore state
        container.style.opacity = '1';
        container.style.pointerEvents = 'auto';
    })
    .catch(error => {
        console.error('Filter error:', error);
        container.style.opacity = '1';
        container.style.pointerEvents = 'auto';
    });
}

function loadPage(page) {
    applyFilters(page);
}

function clearFilters() {
    document.getElementById('typeFilter').value = '';
    document.getElementById('statusFilter').value = '';
    document.getElementById('searchFilter').value = '';
    applyFilters(1);
}

function searchDebounced() {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        applyFilters(1);
    }, 500);
}

// OCR Pause/Resume functionality
let ocrPaused = false;
let lastLogCheck = Date.now();
let previousDocId = null;

// Add log entry to activity log
function addLogEntry(message, type = 'info') {
    const logEntries = document.getElementById('log-entries');
    if (!logEntries) return;

    const timestamp = new Date().toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.style.padding = '2px 0';
    entry.style.borderLeft = '2px solid ' + (type === 'success' ? 'var(--green)' : type === 'error' ? 'var(--red)' : type === 'warning' ? 'var(--orange)' : 'var(--cyan)');
    entry.style.paddingLeft = '8px';
    entry.style.marginBottom = '4px';

    const icon = type === 'success' ? '‚úì' : type === 'error' ? '‚úó' : type === 'warning' ? '‚ö†' : '‚Üí';
    const color = type === 'success' ? 'var(--green)' : type === 'error' ? 'var(--red)' : type === 'warning' ? 'var(--orange)' : 'var(--gray)';

    entry.innerHTML = `<span style="color: var(--dark-gray);">[${timestamp}]</span> <span style="color: ${color};">${icon}</span> <span style="color: var(--white);">${message}</span>`;

    logEntries.appendChild(entry);

    // Keep only last 50 entries
    while (logEntries.children.length > 50) {
        logEntries.removeChild(logEntries.firstChild);
    }

    // Auto-scroll to bottom
    const logContainer = document.getElementById('ocr-activity-log');
    if (logContainer) {
        logContainer.scrollTop = logContainer.scrollHeight;
    }
}

// Clear log entries
function clearLog() {
    const logEntries = document.getElementById('log-entries');
    if (logEntries) {
        logEntries.innerHTML = '<div class="log-entry" style="padding: 2px 0;">‚è≥ waiting for activity...</div>';
    }
}

async function toggleOCRProcessing() {
    const btn = document.getElementById('ocr-pause-btn');
    const statusIcon = document.getElementById('ocr-status-icon');
    const statusText = document.getElementById('ocr-status-text');
    const spinner = document.getElementById('ocr-spinner');
    const box = document.getElementById('ocr-processing-box');

    // Disable button during request
    btn.disabled = true;
    btn.style.opacity = '0.5';

    try {
        const endpoint = ocrPaused ? '{% url "documents:api_ocr_resume" %}' : '{% url "documents:api_ocr_pause" %}';

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            }
        });

        if (response.ok) {
            const data = await response.json();
            ocrPaused = data.is_paused;

            // Update UI based on pause state
            if (ocrPaused) {
                // PAUSED state
                btn.textContent = '‚ñ∂Ô∏è resume processing';
                statusIcon.textContent = '‚è∏Ô∏è';
                statusText.textContent = 'ocr processing paused';
                spinner.style.display = 'none';
                box.style.background = 'rgba(100, 100, 100, 0.1)';
                box.style.borderColor = 'var(--gray)';
                addLogEntry('OCR processing PAUSED by user', 'warning');
                addLogEntry('Background processor will stop after current document', 'info');
            } else {
                // RUNNING state
                btn.textContent = '‚è∏Ô∏è pause processing';
                statusIcon.textContent = 'üîÑ';
                statusText.textContent = 'active ocr processing';
                spinner.style.display = 'inline-block';
                box.style.background = 'rgba(255, 140, 0, 0.1)';
                box.style.borderColor = 'var(--orange)';
                addLogEntry('OCR processing RESUMED by user', 'success');
                addLogEntry('Background processor will continue processing queue', 'info');
            }

            console.log(`OCR processing ${ocrPaused ? 'paused' : 'resumed'}`);
        } else {
            alert('Failed to toggle OCR processing. Please try again.');
        }
    } catch (error) {
        console.error('Error toggling OCR:', error);
        alert(`Error: ${error.message}`);
    } finally {
        // Re-enable button
        btn.disabled = false;
        btn.style.opacity = '1';
    }
}

// Check OCR pause status on page load
async function checkOCRStatus() {
    try {
        const response = await fetch('{% url "documents:api_ocr_status" %}');
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.is_paused) {
                ocrPaused = true;
                // Update UI to show paused state
                const btn = document.getElementById('ocr-pause-btn');
                const statusIcon = document.getElementById('ocr-status-icon');
                const statusText = document.getElementById('ocr-status-text');
                const spinner = document.getElementById('ocr-spinner');
                const box = document.getElementById('ocr-processing-box');

                if (btn && statusIcon && statusText && spinner && box) {
                    btn.textContent = '‚ñ∂Ô∏è resume processing';
                    statusIcon.textContent = '‚è∏Ô∏è';
                    statusText.textContent = 'ocr processing paused';
                    spinner.style.display = 'none';
                    box.style.background = 'rgba(100, 100, 100, 0.1)';
                    box.style.borderColor = 'var(--gray)';
                }
            }
        }
    } catch (error) {
        console.error('Error checking OCR status:', error);
    }
}

// Call checkOCRStatus when page loads
document.addEventListener('DOMContentLoaded', function() {
    checkOCRStatus();
});

</script>
{% endblock %}