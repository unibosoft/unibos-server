<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Game Button Fix Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #1e5620; color: white; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .success { color: #44ff44; }
        .error { color: #ff4444; }
        button { padding: 10px 20px; margin: 10px; background: #ff6b35; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #ff7d4d; }
        .game-state { background: #333; padding: 10px; border-radius: 5px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>New Game Button Fix Test</h1>
    
    <div class="section">
        <h3>Test Scenario</h3>
        <p>This tests the fixed new game functionality:</p>
        <ol>
            <li>Creates initial game state (simulates backend)</li>
            <li>Tests new game creation via API call</li>
            <li>Verifies proper game state replacement</li>
        </ol>
    </div>
    
    <div class="section">
        <h3>Current Game State</h3>
        <div id="current-state" class="game-state"></div>
        <button onclick="simulateNewGame()">Simulate New Game</button>
        <button onclick="resetToOldGame()">Reset to Old Game</button>
    </div>
    
    <div class="section">
        <h3>Test Results</h3>
        <div id="test-results"></div>
    </div>
    
    <script>
        let currentGame = null;
        
        // Mock initial game state
        const initialGameState = {
            stock: generateCards(24),
            waste: [],
            foundations: {spades: [], hearts: [], diamonds: [], clubs: []},
            tableau: [
                generateCards(1),
                generateCards(2),
                generateCards(3),
                generateCards(4),
                generateCards(5),
                generateCards(6),
                generateCards(7)
            ],
            score: 150,
            moves: 25,
            time: 300
        };
        
        // Mock new game state (what API would return)
        const newGameState = {
            stock: generateCards(24, 'new'),
            waste: [],
            foundations: {spades: [], hearts: [], diamonds: [], clubs: []},
            tableau: [
                generateCards(1, 'new'),
                generateCards(2, 'new'),
                generateCards(3, 'new'),
                generateCards(4, 'new'),
                generateCards(5, 'new'),
                generateCards(6, 'new'),
                generateCards(7, 'new')
            ],
            score: 0,
            moves: 0,
            time: 0
        };
        
        function generateCards(count, prefix = 'card') {
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const cards = [];
            
            for (let i = 0; i < count; i++) {
                cards.push({
                    suit: suits[i % 4],
                    rank: ranks[i % 13],
                    face_up: i === count - 1, // Only last card face up
                    id: `${prefix}_${i}`
                });
            }
            
            return cards;
        }
        
        function convertCard(card) {
            const suitMap = { 'clubs': 3, 'hearts': 1, 'diamonds': 2, 'spades': 0 };
            const values = { A: 1, J: 11, Q: 12, K: 13 };
            
            if (!card) return null;
            
            const suitIndex = suitMap[card.suit] || 0;
            return {
                suit: suitIndex,
                rank: card.rank || 'A',
                value: values[card.rank] || parseInt(card.rank) || 1,
                color: (suitIndex === 1 || suitIndex === 2) ? 'red' : 'black',
                faceUp: card.face_up === true,
                id: card.id
            };
        }
        
        function createGameFromBackendState(backendState) {
            return {
                deck: [],
                stock: backendState.stock ? backendState.stock.map(convertCard) : [],
                waste: backendState.waste ? backendState.waste.map(convertCard) : [],
                foundations: backendState.foundations ? 
                    [
                        backendState.foundations.spades ? backendState.foundations.spades.map(convertCard) : [],
                        backendState.foundations.hearts ? backendState.foundations.hearts.map(convertCard) : [],
                        backendState.foundations.diamonds ? backendState.foundations.diamonds.map(convertCard) : [],
                        backendState.foundations.clubs ? backendState.foundations.clubs.map(convertCard) : []
                    ] : [[], [], [], []],
                tableau: backendState.tableau ? 
                    backendState.tableau.map((pile) => {
                        if (!pile) return [];
                        return pile.map((card) => convertCard(card));
                    }) : [[], [], [], [], [], [], []],
                score: backendState.score || 0,
                moves: backendState.moves || 0,
                moveHistory: backendState.move_history || [],
                undoStack: [],
                lastMoveTime: Date.now()
            };
        }
        
        function displayGameState(game) {
            const stateDiv = document.getElementById('current-state');
            stateDiv.innerHTML = `
                <strong>Stock:</strong> ${game.stock.length} cards<br>
                <strong>Waste:</strong> ${game.waste.length} cards<br>
                <strong>Tableau:</strong> [${game.tableau.map(p => p.length).join(', ')}] cards<br>
                <strong>Score:</strong> ${game.score}<br>
                <strong>Moves:</strong> ${game.moves}<br>
                <strong>Sample Stock Card:</strong> ${game.stock.length > 0 ? game.stock[0].id : 'none'}<br>
                <strong>Sample Tableau Card:</strong> ${game.tableau[0].length > 0 ? game.tableau[0][0].id : 'none'}
            `;
        }
        
        function simulateNewGame() {
            const results = document.getElementById('test-results');
            results.innerHTML = '<h4>Running New Game Test...</h4>';
            
            try {
                // Step 1: Verify current game has old state
                if (!currentGame || currentGame.score !== 150) {
                    results.innerHTML += '<div class="error">‚ùå Current game does not have expected old state</div>';
                    return;
                }
                results.innerHTML += '<div class="success">‚úÖ Current game has old state (score: 150, moves: 25)</div>';
                
                // Step 2: Simulate API call to create new game
                results.innerHTML += '<div>üì° Simulating API call to /solitaire/api/new_game/...</div>';
                
                // Step 3: Simulate successful API response
                const apiResponse = {
                    success: true,
                    session_id: 'new-session-123',
                    game_state: newGameState
                };
                
                results.innerHTML += '<div class="success">‚úÖ API returned new game state</div>';
                
                // Step 4: Apply the NEW FIXED logic (uses backend state directly)
                const oldStock = currentGame.stock[0] ? currentGame.stock[0].id : 'none';
                
                currentGame = createGameFromBackendState(apiResponse.game_state);
                
                const newStock = currentGame.stock[0] ? currentGame.stock[0].id : 'none';
                
                results.innerHTML += `<div class="success">‚úÖ Game state replaced successfully</div>`;
                results.innerHTML += `<div>Old stock card: ${oldStock} ‚Üí New stock card: ${newStock}</div>`;
                
                // Step 5: Verify new game properties
                if (currentGame.score !== 0) {
                    results.innerHTML += '<div class="error">‚ùå Score should be 0 in new game</div>';
                    return;
                }
                
                if (currentGame.moves !== 0) {
                    results.innerHTML += '<div class="error">‚ùå Moves should be 0 in new game</div>';
                    return;
                }
                
                if (currentGame.stock.length !== 24) {
                    results.innerHTML += '<div class="error">‚ùå Stock should have 24 cards</div>';
                    return;
                }
                
                const tableauCounts = currentGame.tableau.map(p => p.length);
                if (JSON.stringify(tableauCounts) !== JSON.stringify([1, 2, 3, 4, 5, 6, 7])) {
                    results.innerHTML += '<div class="error">‚ùå Tableau should have [1,2,3,4,5,6,7] cards</div>';
                    return;
                }
                
                results.innerHTML += '<div class="success">‚úÖ All new game validations passed!</div>';
                results.innerHTML += '<div class="success"><strong>üéâ NEW GAME BUTTON FIX WORKS CORRECTLY!</strong></div>';
                
                // Update display
                displayGameState(currentGame);
                
            } catch (error) {
                results.innerHTML += `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }
        
        function resetToOldGame() {
            currentGame = createGameFromBackendState(initialGameState);
            displayGameState(currentGame);
            document.getElementById('test-results').innerHTML = '<div>Reset to old game state</div>';
        }
        
        // Initialize
        window.onload = function() {
            resetToOldGame();
        };
    </script>
</body>
</html>