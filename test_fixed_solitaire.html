<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unicorn solitaire</title>
    
    <!-- AGGRESSIVE CACHE BUSTING -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <style id="solitaire-critical-css-v3">
        /* CRITICAL INLINE CSS - VERSION 3.2 - MS SOLITAIRE STYLE */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        /* Game container - fullscreen */
        .game-container {
            width: 100vw;
            height: 100vh;
            background: #1e5620;
            background-image: 
                radial-gradient(ellipse at center, #2a6f2e 0%, #1e5620 100%);
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        /* Game toolbar - UNIBOS style */
        .game-toolbar {
            height: 40px;
            background: #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .toolbar-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        .toolbar-right {
            position: absolute;
            right: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            color: white;
            font-size: 13px;
        }
        
        .toolbar-btn {
            padding: 6px 18px;
            background: linear-gradient(to bottom, #ff6b35, #e55a2b);
            border: 1px solid #d54521;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .toolbar-btn:hover {
            background: linear-gradient(to bottom, #ff7d4d, #ff6b35);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            transform: translateY(-1px);
        }
        
        .toolbar-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .score-display, .time-display {
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        /* Game board - centered */
        .game-board {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 40px;
            width: 100%;
        }
        
        /* Game area container */
        .game-area {
            position: relative;
            width: 935px;
            height: 715px;
        }
        
        /* Card styles */
        .card {
            position: absolute;
            width: 110px;
            height: 148px;
            border-radius: 13px;
            cursor: pointer;
            transition: transform 0.1s;
            will-change: transform;
        }
        
        .card.dragging {
            z-index: 1000 !important;
            cursor: grabbing !important;
            opacity: 0.95;
        }
        
        /* Card face */
        .card.face-up {
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
            border: 1px solid #bbb;
            box-shadow: 
                0 2px 5px rgba(0, 0, 0, 0.08),
                0 1px 2px rgba(0, 0, 0, 0.06),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            padding: 6px;
            font-family: 'Trebuchet MS', 'Lucida Grande', 'Lucida Sans', Tahoma, sans-serif;
        }
        
        /* Card back */
        .card.face-down {
            background: linear-gradient(135deg, #3d3d3d 0%, #2d2d2d 100%);
            border: 1px solid #222;
            box-shadow: 
                0 3px 6px rgba(0, 0, 0, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }
        
        .card.face-down::after {
            content: 'ðŸ¦„';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            opacity: 0.2;
            filter: contrast(0.8);
        }
        
        /* Card content */
        .card-corner {
            position: absolute;
            font-size: 13px;
            font-weight: 400;
            line-height: 1.1;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Trebuchet MS', 'Lucida Grande', Tahoma, sans-serif;
        }
        
        .card-corner.top-left {
            top: 8px;
            left: 8px;
        }
        
        .card-corner.bottom-right {
            bottom: 8px;
            right: 8px;
            transform: rotate(180deg);
        }
        
        .card-rank {
            font-size: 20px;
            font-weight: 400;
            letter-spacing: 0.5px;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }
        
        .card-suit {
            font-size: 18px;
            margin-top: -1px;
            filter: brightness(0.95);
        }
        
        .card-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            opacity: 0.85;
            filter: brightness(0.95);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
        
        .card.red .card-rank {
            color: #d84040;
            text-shadow: 0 0.5px 1px rgba(216, 64, 64, 0.15);
        }
        
        .card.red .card-suit,
        .card.red .card-center {
            color: #c73636;
        }
        
        .card.black .card-rank {
            color: #4a4a4a;
            text-shadow: 0 0.5px 1px rgba(74, 74, 74, 0.1);
        }
        
        .card.black .card-suit,
        .card.black .card-center {
            color: #3a3a3a;
        }
        
        /* Card slots */
        .card-slot {
            position: absolute;
            width: 110px;
            height: 148px;
            border: 2px dashed rgba(0, 0, 0, 0.2);
            border-radius: 13px;
            background: transparent;
        }
        
        /* Stock and Waste slots */
        .card-slot#stock,
        .card-slot#waste {
            background: rgba(0, 0, 0, 0.15);
            border: 2px solid rgba(0, 0, 0, 0.3);
        }
        
        .card-slot#stock {
            cursor: pointer;
        }
        
        .card-slot#stock:hover {
            background: rgba(0, 0, 0, 0.25);
        }
        
        /* Foundation slots */
        .card-slot[id^="foundation-"] {
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(0, 0, 0, 0.4);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        /* Tableau slots */
        .card-slot[id^="tableau-"] {
            height: 450px;
            overflow: visible;
            background: transparent;
            border: none;
            box-shadow: none;
        }
        
        .card-slot.can-drop {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }
        
        /* Pile positions */
        /* Stock and Waste - TOP LEFT */
        .stock, #stock { top: 0px; left: 0px; }
        .waste, #waste { top: 0px; left: 132px; }
        
        /* Foundations - TOP RIGHT */
        .foundation-0, #foundation-0 { top: 0px; right: 396px; }
        .foundation-1, #foundation-1 { top: 0px; right: 264px; }
        .foundation-2, #foundation-2 { top: 0px; right: 132px; }
        .foundation-3, #foundation-3 { top: 0px; right: 0px; }
        
        /* Tableau columns - BELOW */
        .tableau-0, #tableau-0 { top: 176px; left: 0px; }
        .tableau-1, #tableau-1 { top: 176px; left: 126px; }
        .tableau-2, #tableau-2 { top: 176px; left: 253px; }
        .tableau-3, #tableau-3 { top: 176px; left: 379px; }
        .tableau-4, #tableau-4 { top: 176px; left: 506px; }
        .tableau-5, #tableau-5 { top: 176px; left: 632px; }
        .tableau-6, #tableau-6 { top: 176px; left: 759px; }
        
        /* Exit dialog */
        .exit-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }
        
        .exit-dialog.show {
            display: flex;
        }
        
        .exit-dialog-content {
            background: #2a2a2a;
            border: 2px solid #ff6b35;
            padding: 30px;
            border-radius: 10px;
            min-width: 400px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }
        
        .exit-dialog h3 {
            margin-bottom: 20px;
            font-size: 18px;
            color: #ff6b35;
            font-weight: bold;
            text-align: center;
        }
        
        .exit-dialog input {
            width: 100%;
            padding: 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            color: white;
        }
        
        .exit-dialog input:focus {
            outline: none;
            border-color: #ff6b35;
            box-shadow: 0 0 5px rgba(255, 107, 53, 0.3);
        }
        
        .exit-dialog .error {
            color: #ff4444;
            font-size: 12px;
            margin-bottom: 10px;
            display: none;
            text-align: center;
        }
        
        .exit-dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .exit-dialog button {
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .exit-dialog .btn-cancel {
            background: #555;
            color: white;
        }
        
        .exit-dialog .btn-cancel:hover {
            background: #666;
        }
        
        .exit-dialog .btn-confirm {
            background: linear-gradient(to bottom, #ff6b35, #e55a2b);
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .exit-dialog .btn-confirm:hover {
            background: linear-gradient(to bottom, #ff7d4d, #ff6b35);
        }
        
        .exit-dialog button:hover {
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Toolbar -->
        <div class="game-toolbar">
            <div style="position: absolute; left: 20px; color: white; font-size: 16px;">unicorn solitaire</div>
            <div class="toolbar-center">
                <button class="toolbar-btn" onclick="newGame()">new game</button>
                <button class="toolbar-btn" onclick="undoMove()">undo</button>
                <button class="toolbar-btn" onclick="showHint()">auto</button>
            </div>
            <div class="toolbar-right">
                <div>moves: <span id="moves">0</span></div>
                <div>score: <span class="score-display" id="score">0</span></div>
                <div>time: <span class="time-display" id="timer">0:00</span></div>
            </div>
        </div>
        
        <!-- Game Board -->
        <div class="game-board" id="gameBoard">
            <div class="game-area">
                <!-- Stock and Waste -->
                <div class="card-slot stock" id="stock"></div>
                <div class="card-slot waste" id="waste"></div>
                
                <!-- Foundations -->
                <div class="card-slot foundation-0" id="foundation-0" data-suit="0"></div>
                <div class="card-slot foundation-1" id="foundation-1" data-suit="1"></div>
                <div class="card-slot foundation-2" id="foundation-2" data-suit="2"></div>
                <div class="card-slot foundation-3" id="foundation-3" data-suit="3"></div>
                
                <!-- Tableau -->
                <div class="card-slot tableau-0" id="tableau-0"></div>
                <div class="card-slot tableau-1" id="tableau-1"></div>
                <div class="card-slot tableau-2" id="tableau-2"></div>
                <div class="card-slot tableau-3" id="tableau-3"></div>
                <div class="card-slot tableau-4" id="tableau-4"></div>
                <div class="card-slot tableau-5" id="tableau-5"></div>
                <div class="card-slot tableau-6" id="tableau-6"></div>
            </div>
        </div>
    </div>
    
    <!-- Exit Dialog -->
    <div class="exit-dialog" id="exitDialog">
        <div class="exit-dialog-content">
            <h3>Enter Screen Lock Code to Exit</h3>
            <input type="password" id="screenLockCode" placeholder="Enter code..." autofocus onkeypress="if(event.key === 'Enter') confirmExit()">
            <div class="error" id="errorMsg"></div>
            <div class="exit-dialog-buttons">
                <button class="btn-cancel" onclick="cancelExit()">Cancel</button>
                <button class="btn-confirm" onclick="confirmExit()">OK</button>
            </div>
        </div>
    </div>
    
    <!-- New Game Dialog -->
    <div class="exit-dialog" id="newGameDialog">
        <div class="exit-dialog-content">
            <h3>start new game?</h3>
            <p style="color: #ccc; font-size: 14px; margin: 15px 0;">your current progress will be lost</p>
            <div class="exit-dialog-buttons">
                <button class="btn-cancel" onclick="cancelNewGame()">cancel</button>
                <button class="btn-confirm" onclick="confirmNewGame()">new game</button>
            </div>
        </div>
    </div>
    
    <script>
        // Get game state from backend
        const initialGameState = {"stock": [{"suit": "diamonds", "rank": "6", "face_up": false}, {"suit": "diamonds", "rank": "4", "face_up": false}, {"suit": "diamonds", "rank": "3", "face_up": false}, {"suit": "spades", "rank": "5", "face_up": false}, {"suit": "spades", "rank": "8", "face_up": false}, {"suit": "diamonds", "rank": "9", "face_up": false}, {"suit": "spades", "rank": "6", "face_up": false}, {"suit": "diamonds", "rank": "Q", "face_up": false}, {"suit": "clubs", "rank": "4", "face_up": false}, {"suit": "hearts", "rank": "K", "face_up": false}, {"suit": "clubs", "rank": "9", "face_up": false}, {"suit": "hearts", "rank": "4", "face_up": false}, {"suit": "hearts", "rank": "A", "face_up": false}, {"suit": "spades", "rank": "A", "face_up": false}, {"suit": "spades", "rank": "4", "face_up": false}, {"suit": "spades", "rank": "9", "face_up": false}, {"suit": "hearts", "rank": "2", "face_up": false}, {"suit": "clubs", "rank": "6", "face_up": false}, {"suit": "clubs", "rank": "5", "face_up": false}, {"suit": "diamonds", "rank": "A", "face_up": false}, {"suit": "clubs", "rank": "7", "face_up": false}, {"suit": "hearts", "rank": "J", "face_up": false}, {"suit": "hearts", "rank": "7", "face_up": false}, {"suit": "hearts", "rank": "3", "face_up": false}], "waste": [], "foundations": {"spades": [], "hearts": [], "diamonds": [], "clubs": []}, "tableau": [[{"suit": "diamonds", "rank": "8", "face_up": true}], [{"suit": "clubs", "rank": "2", "face_up": false}, {"suit": "spades", "rank": "Q", "face_up": true}], [{"suit": "hearts", "rank": "8", "face_up": false}, {"suit": "diamonds", "rank": "2", "face_up": false}, {"suit": "clubs", "rank": "10", "face_up": true}], [{"suit": "clubs", "rank": "K", "face_up": false}, {"suit": "hearts", "rank": "6", "face_up": false}, {"suit": "spades", "rank": "10", "face_up": false}, {"suit": "spades", "rank": "2", "face_up": true}], [{"suit": "clubs", "rank": "3", "face_up": false}, {"suit": "diamonds", "rank": "10", "face_up": false}, {"suit": "spades", "rank": "7", "face_up": false}, {"suit": "spades", "rank": "K", "face_up": false}, {"suit": "clubs", "rank": "J", "face_up": true}], [{"suit": "hearts", "rank": "10", "face_up": false}, {"suit": "clubs", "rank": "8", "face_up": false}, {"suit": "diamonds", "rank": "5", "face_up": false}, {"suit": "hearts", "rank": "5", "face_up": false}, {"suit": "spades", "rank": "3", "face_up": false}, {"suit": "clubs", "rank": "Q", "face_up": true}], [{"suit": "spades", "rank": "J", "face_up": false}, {"suit": "diamonds", "rank": "J", "face_up": false}, {"suit": "diamonds", "rank": "K", "face_up": false}, {"suit": "clubs", "rank": "A", "face_up": false}, {"suit": "diamonds", "rank": "7", "face_up": false}, {"suit": "hearts", "rank": "9", "face_up": false}, {"suit": "hearts", "rank": "Q", "face_up": true}]], "moves": 0, "score": 0, "time": 0, "is_won": false};
        const sessionId = '41e57bfc-e04a-4789-957d-56b0eee8b6d1';
        
        
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const values = { A: 1, J: 11, Q: 12, K: 13 };
        
        // Initialize saveTimer globally
        let saveTimer = null;
        
        // Convert backend card format to frontend format
        function convertCard(card) {
            if (!card) {
                console.error('convertCard called with null/undefined card');
                return null;
            }
            
            const suitMap = {
                'clubs': 3,    // â™£
                'hearts': 1,   // â™¥
                'diamonds': 2, // â™¦
                'spades': 0    // â™ 
            };
            
            const suitIndex = typeof card.suit === 'string' ? suitMap[card.suit] : card.suit;
            
            if (suitIndex === undefined || suitIndex === null) {
                console.error('Invalid suit:', card.suit);
                return null;
            }
            
            return {
                suit: suitIndex,
                rank: card.rank || 'A',
                value: card.value || values[card.rank] || parseInt(card.rank) || 1,
                color: (suitIndex === 1 || suitIndex === 2) ? 'red' : 'black',
                faceUp: card.face_up === true  // Only true if explicitly true, false otherwise
            };
        }
        
        // Check if we have valid game state from backend
        const hasValidState = initialGameState && 
            initialGameState.tableau && 
            Array.isArray(initialGameState.tableau) &&
            initialGameState.tableau.some(pile => pile && pile.length > 0);
        
        
        let game = {
            deck: [],
            stock: hasValidState && initialGameState.stock ? initialGameState.stock.map(convertCard) : [],
            waste: hasValidState && initialGameState.waste ? initialGameState.waste.map(convertCard) : [],
            foundations: hasValidState && initialGameState.foundations ? 
                (Array.isArray(initialGameState.foundations) ? 
                    initialGameState.foundations.map(pile => pile ? pile.map(convertCard) : []) :
                    [
                        initialGameState.foundations.clubs ? initialGameState.foundations.clubs.map(convertCard) : [],
                        initialGameState.foundations.hearts ? initialGameState.foundations.hearts.map(convertCard) : [],
                        initialGameState.foundations.diamonds ? initialGameState.foundations.diamonds.map(convertCard) : [],
                        initialGameState.foundations.spades ? initialGameState.foundations.spades.map(convertCard) : []
                    ]
                ) : 
                [[], [], [], []],
            tableau: hasValidState && initialGameState.tableau ? 
                initialGameState.tableau.map((pile, pileIndex) => {
                    if (!pile) return [];
                    return pile.map((card, cardIndex) => {
                        const converted = convertCard(card);
                        // FORCE FIX: Ensure top card of each pile is face-up
                        if (cardIndex === pile.length - 1 && converted) {
                            converted.faceUp = true;
                        }
                        return converted;
                    });
                }) : 
                [[], [], [], [], [], [], []],
            score: initialGameState.score || 0,
            moves: initialGameState.moves || 0
        };
        
        
        function createCard(card, faceUp) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            
            // Use the card's own faceUp property if not explicitly overridden
            const shouldShowFace = faceUp !== undefined ? faceUp : (card && card.faceUp);
            
            
            if (shouldShowFace && card) {
                cardEl.classList.add('face-up', card.color);
                
                // Create card elements
                const topLeft = document.createElement('div');
                topLeft.className = 'card-corner top-left';
                topLeft.innerHTML = `
                    <div class="card-rank">${card.rank}</div>
                    <div class="card-suit">${suits[card.suit]}</div>
                `;
                
                const bottomRight = document.createElement('div');
                bottomRight.className = 'card-corner bottom-right';
                bottomRight.innerHTML = `
                    <div class="card-rank">${card.rank}</div>
                    <div class="card-suit">${suits[card.suit]}</div>
                `;
                
                const center = document.createElement('div');
                center.className = 'card-center';
                center.textContent = suits[card.suit];
                
                cardEl.appendChild(topLeft);
                cardEl.appendChild(bottomRight);
                cardEl.appendChild(center);
            } else {
                cardEl.classList.add('face-down');
            }
            
            return cardEl;
        }
        
        function render() {
            // Clear all cards
            document.querySelectorAll('.card').forEach(c => c.remove());
            
            // Trigger auto-save after render (debounced)
            if (typeof debouncedSave !== 'undefined') {
                debouncedSave();
            }
            
            // Render stock - always show face-down
            if (game.stock.length > 0) {
                const stockEl = document.getElementById('stock');
                // Explicitly pass false to show card face-down
                const card = createCard(game.stock[game.stock.length - 1], false);
                card.style.top = '0';
                card.style.left = '0';
                stockEl.appendChild(card);
            }
            
            // Render waste - show up to 3 cards spread horizontally
            if (game.waste.length > 0) {
                const wasteEl = document.getElementById('waste');
                // Show only the last 3 cards
                const cardsToShow = Math.min(3, game.waste.length);
                const startIndex = game.waste.length - cardsToShow;
                
                for (let i = 0; i < cardsToShow; i++) {
                    const card = createCard(game.waste[startIndex + i], true);
                    card.style.top = '0';
                    card.style.left = (i * 25) + 'px'; // Spread cards horizontally
                    card.style.zIndex = i + 1;
                    wasteEl.appendChild(card);
                }
            }
            
            // Render foundations
            for (let f = 0; f < 4; f++) {
                const foundation = document.getElementById('foundation-' + f);
                const pile = game.foundations[f];
                if (pile && pile.length > 0) {
                    const topCard = pile[pile.length - 1];
                    const card = createCard(topCard, true);
                    card.style.top = '0';
                    card.style.left = '0';
                    foundation.appendChild(card);
                }
            }
            
            // Render tableau - proper stacking with consistent spacing
            const CARD_SPACING = {
                FACE_DOWN: 18,  // Tighter spacing for face-down cards
                FACE_UP: 25     // More spacing to show rank/suit on face-up cards
            };
            
            for (let col = 0; col < 7; col++) {
                const tableau = document.getElementById('tableau-' + col);
                const pile = game.tableau[col];
                
                pile.forEach((card, index) => {
                    // Pass the card's faceUp property explicitly
                    const cardEl = createCard(card, card.faceUp);
                    
                    // Calculate cumulative offset based on all previous cards
                    let yOffset = 0;
                    for (let i = 0; i < index; i++) {
                        yOffset += pile[i].faceUp ? CARD_SPACING.FACE_UP : CARD_SPACING.FACE_DOWN;
                    }
                    
                    cardEl.style.position = 'absolute';
                    cardEl.style.top = yOffset + 'px';
                    cardEl.style.left = '0';
                    cardEl.style.zIndex = index;
                    
                    // Add drag and double-click handlers for face-up cards
                    if (card.faceUp) {
                        cardEl.draggable = true;
                        cardEl.dataset.pile = 'tableau';
                        cardEl.dataset.column = col;
                        cardEl.dataset.index = index;
                        
                        // Drag events
                        cardEl.addEventListener('dragstart', handleDragStart);
                        cardEl.addEventListener('dragend', handleDragEnd);
                        
                        // Double-click to auto-move
                        cardEl.addEventListener('dblclick', function() {
                            if (index === pile.length - 1) {
                                // Only top card can be auto-moved
                                if (tryAutoMoveToFoundation(card, pile)) {
                                    // Flip next card if needed
                                    if (pile.length > 0 && !pile[pile.length - 1].faceUp) {
                                        pile[pile.length - 1].faceUp = true;
                                    }
                                    game.moves++;
                                    document.getElementById('moves').textContent = game.moves;
                                    render();
                                    saveGameState();
                                }
                            }
                        });
                    }
                    
                    tableau.appendChild(cardEl);
                });
            }
            
            console.log('Render complete');
        }
        
        function initGame() {
            console.log('Initializing game...');
            console.log('hasValidState:', hasValidState);
            console.log('game.tableau:', game.tableau);
            
            // If we have valid state from backend, just render it
            if (hasValidState && game.tableau && game.tableau.some(pile => pile && pile.length > 0)) {
                console.log('Using existing game state from backend');
                console.log('Stock:', game.stock.length, 'Tableau:', game.tableau.map(p => p ? p.length : 0));
                
                // Restore timer if we have time from backend
                if (initialGameState.time) {
                    const savedTime = initialGameState.time;
                    startTime = Date.now() - (savedTime * 1000);
                }
                
                // Update UI with saved values
                document.getElementById('score').textContent = game.score;
                document.getElementById('moves').textContent = game.moves;
                
                render();
                return;
            }
            
            // Otherwise create new game
            console.log('Creating new game locally...');
            console.warn('No valid state found, creating new game');
            
            // Create deck
            for (let s = 0; s < 4; s++) {
                for (let r = 0; r < 13; r++) {
                    game.deck.push({
                        suit: s,
                        rank: ranks[r],
                        value: values[ranks[r]] || parseInt(ranks[r]),
                        color: (s === 1 || s === 2) ? 'red' : 'black',
                        faceUp: false
                    });
                }
            }
            
            // Shuffle
            for (let i = game.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [game.deck[i], game.deck[j]] = [game.deck[j], game.deck[i]];
            }
            
            // Deal cards
            let cardIndex = 0;
            for (let col = 0; col < 7; col++) {
                for (let row = 0; row <= col; row++) {
                    const card = game.deck[cardIndex++];
                    card.faceUp = (row === col);
                    game.tableau[col].push(card);
                }
            }
            
            // Rest to stock
            while (cardIndex < game.deck.length) {
                game.stock.push(game.deck[cardIndex++]);
            }
            
            console.log('New game created. Stock:', game.stock.length, 'Tableau:', game.tableau.map(p => p.length));
            
            render();
        }
        
        // Stock click handler
        function handleStockClick() {
            if (game.stock.length > 0) {
                // Draw 3 cards from stock to waste
                game.waste = []; // Clear waste first
                for (let i = 0; i < 3 && game.stock.length > 0; i++) {
                    const card = game.stock.pop();
                    card.faceUp = true;
                    game.waste.push(card);
                }
            } else if (game.waste.length > 0) {
                // Return waste to stock
                while (game.waste.length > 0) {
                    const card = game.waste.pop();
                    card.faceUp = false;
                    game.stock.push(card);
                }
            }
            
            game.moves++;
            document.getElementById('moves').textContent = game.moves;
            render();
        }
        
        // Timer variables
        let startTime = Date.now();
        let timerInterval = null;
        
        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
            updateTimer();
        }
        
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }
        
        // Game logic functions
        function canPlaceOnTableau(card, targetCard) {
            if (!targetCard) {
                // Empty pile - only Kings can go here
                return card.rank === 'K';
            }
            // Different color and one rank lower
            const isOppositeColor = card.color !== targetCard.color;
            const isOneLower = card.value === targetCard.value - 1;
            return isOppositeColor && isOneLower;
        }
        
        function canPlaceOnFoundation(card, foundation) {
            if (foundation.length === 0) {
                // Empty foundation - only Aces
                return card.rank === 'A';
            }
            const topCard = foundation[foundation.length - 1];
            // Same suit and one rank higher
            return card.suit === topCard.suit && card.value === topCard.value + 1;
        }
        
        function tryAutoMoveToFoundation(card, fromPile) {
            // Try to auto-move card to appropriate foundation
            for (let f = 0; f < 4; f++) {
                if (canPlaceOnFoundation(card, game.foundations[f])) {
                    // Remove from source
                    fromPile.pop();
                    // Add to foundation
                    game.foundations[f].push(card);
                    // Update score
                    game.score += 10;
                    document.getElementById('score').textContent = game.score;
                    return true;
                }
            }
            return false;
        }
        
        // Drag and drop variables
        let draggedCards = [];
        let draggedFrom = null;
        let dragGhost = null;
        
        // Drag and drop handlers
        function handleDragStart(e) {
            const pile = e.target.dataset.pile;
            const col = parseInt(e.target.dataset.column);
            const index = parseInt(e.target.dataset.index);
            
            if (pile === 'tableau') {
                // Get all cards from this index to end
                draggedCards = game.tableau[col].slice(index);
                draggedFrom = { type: 'tableau', column: col, index: index };
            } else if (pile === 'waste') {
                // Only top card from waste
                draggedCards = [game.waste[game.waste.length - 1]];
                draggedFrom = { type: 'waste' };
            }
            
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedCards = [];
            draggedFrom = null;
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        
        function handleDrop(e) {
            e.preventDefault();
            
            if (!draggedCards.length || !draggedFrom) return;
            
            const targetEl = e.target.closest('.card-slot');
            if (!targetEl) return;
            
            const targetId = targetEl.id;
            let moved = false;
            
            if (targetId.startsWith('tableau-')) {
                const col = parseInt(targetId.split('-')[1]);
                const targetPile = game.tableau[col];
                const targetCard = targetPile.length > 0 ? targetPile[targetPile.length - 1] : null;
                
                if (canPlaceOnTableau(draggedCards[0], targetCard)) {
                    // Remove from source
                    if (draggedFrom.type === 'tableau') {
                        game.tableau[draggedFrom.column].splice(draggedFrom.index);
                    } else if (draggedFrom.type === 'waste') {
                        game.waste.pop();
                    }
                    
                    // Add to target
                    draggedCards.forEach(card => targetPile.push(card));
                    moved = true;
                    
                    // Flip card in source if needed
                    if (draggedFrom.type === 'tableau') {
                        const sourcePile = game.tableau[draggedFrom.column];
                        if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp) {
                            sourcePile[sourcePile.length - 1].faceUp = true;
                        }
                    }
                }
            } else if (targetId.startsWith('foundation-') && draggedCards.length === 1) {
                const f = parseInt(targetId.split('-')[1]);
                if (canPlaceOnFoundation(draggedCards[0], game.foundations[f])) {
                    // Remove from source
                    if (draggedFrom.type === 'tableau') {
                        game.tableau[draggedFrom.column].pop();
                        // Flip next card if needed
                        const sourcePile = game.tableau[draggedFrom.column];
                        if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp) {
                            sourcePile[sourcePile.length - 1].faceUp = true;
                        }
                    } else if (draggedFrom.type === 'waste') {
                        game.waste.pop();
                    }
                    
                    // Add to foundation
                    game.foundations[f].push(draggedCards[0]);
                    game.score += 10;
                    moved = true;
                }
            }
            
            if (moved) {
                game.moves++;
                document.getElementById('moves').textContent = game.moves;
                document.getElementById('score').textContent = game.score;
                render();
                saveGameState();
            }
        }
        
        // Save game state to backend
        function saveGameState() {
            if (!sessionId) {
                console.warn('No session ID, cannot save');
                return;
            }
            
            // Convert frontend format back to backend format
            const backendGameState = {
                stock: game.stock.map(card => ({
                    suit: ['spades', 'hearts', 'diamonds', 'clubs'][card.suit],
                    rank: card.rank,
                    face_up: card.faceUp || false
                })),
                waste: game.waste.map(card => ({
                    suit: ['spades', 'hearts', 'diamonds', 'clubs'][card.suit],
                    rank: card.rank,
                    face_up: true  // Waste cards are always face-up
                })),
                foundations: {
                    spades: game.foundations[0]?.map(card => ({
                        suit: 'spades',
                        rank: card.rank,
                        face_up: true
                    })) || [],
                    hearts: game.foundations[1]?.map(card => ({
                        suit: 'hearts',
                        rank: card.rank,
                        face_up: true
                    })) || [],
                    diamonds: game.foundations[2]?.map(card => ({
                        suit: 'diamonds',
                        rank: card.rank,
                        face_up: true
                    })) || [],
                    clubs: game.foundations[3]?.map(card => ({
                        suit: 'clubs',
                        rank: card.rank,
                        face_up: true
                    })) || []
                },
                tableau: game.tableau.map(pile => 
                    pile.map(card => ({
                        suit: ['spades', 'hearts', 'diamonds', 'clubs'][card.suit],
                        rank: card.rank,
                        face_up: card.faceUp || false
                    }))
                ),
                score: game.score,
                moves: game.moves,
                time: Math.floor((Date.now() - startTime) / 1000),
                is_won: false
            };
            
            fetch('/solitaire/api/save/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    session_id: sessionId,
                    game_state: backendGameState,
                    score: game.score,
                    moves: game.moves,
                    time: Math.floor((Date.now() - startTime) / 1000)
                })
            }).catch(err => console.log('Save error:', err));
        }
        
        // Get CSRF token
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        // Setup drop zones
        function setupDropZones() {
            // Add drop handlers to all tableau and foundation slots
            document.querySelectorAll('.card-slot').forEach(slot => {
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('drop', handleDrop);
            });
        }
        
        // Add drag handlers to waste cards
        function addWasteCardHandlers() {
            const wasteEl = document.getElementById('waste');
            const cards = wasteEl.querySelectorAll('.card');
            if (cards.length > 0) {
                const topCard = cards[cards.length - 1];
                topCard.draggable = true;
                topCard.dataset.pile = 'waste';
                topCard.addEventListener('dragstart', handleDragStart);
                topCard.addEventListener('dragend', handleDragEnd);
                
                // Double-click handler
                topCard.addEventListener('dblclick', function() {
                    const card = game.waste[game.waste.length - 1];
                    if (tryAutoMoveToFoundation(card, game.waste)) {
                        game.moves++;
                        document.getElementById('moves').textContent = game.moves;
                        render();
                        saveGameState();
                    }
                });
            }
        }
        
        // Update render to call addWasteCardHandlers
        const originalRender = render;
        render = function() {
            originalRender();
            addWasteCardHandlers();
        };
        
        // Start the game
        initGame();
        startTimer();
        setupDropZones();
        
        // Add event listeners
        document.getElementById('stock').addEventListener('click', handleStockClick);
        
        // Save game state after moves and periodically
        function debouncedSave() {
            // Cancel previous save timer
            if (saveTimer) {
                clearTimeout(saveTimer);
            }
            // Save after 2 seconds of inactivity
            saveTimer = setTimeout(saveGameState, 2000);
        }
        
        // Auto-save every 30 seconds
        setInterval(saveGameState, 30000);
        
        // Exit functions
        function showExitDialog() {
            document.getElementById('exitDialog').classList.add('show');
            document.getElementById('screenLockCode').focus();
        }
        
        function cancelExit() {
            document.getElementById('exitDialog').classList.remove('show');
            document.getElementById('screenLockCode').value = '';
            document.getElementById('errorMsg').style.display = 'none';
        }
        
        function confirmExit() {
            const code = document.getElementById('screenLockCode').value;
            
            if (!code) {
                document.getElementById('errorMsg').textContent = 'Please enter code';
                document.getElementById('errorMsg').style.display = 'block';
                return;
            }
            
            // Save game state before exit
            saveGameState();
            
            // Create form data for POST request
            const formData = new FormData();
            formData.append('password', code);
            
            // Verify screen lock code
            fetch('/administration/unlock/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Redirect to main page (root URL)
                    window.location.href = '/';
                } else {
                    document.getElementById('errorMsg').textContent = data.error || 'Invalid code';
                    document.getElementById('errorMsg').style.display = 'block';
                    document.getElementById('screenLockCode').value = '';
                    document.getElementById('screenLockCode').focus();
                }
            })
            .catch(err => {
                console.error('Unlock error:', err);
                document.getElementById('errorMsg').textContent = 'Error verifying code';
                document.getElementById('errorMsg').style.display = 'block';
            });
        }
        
        // Keyboard handlers
        document.addEventListener('keydown', function(e) {
            // Don't handle keys if dialog is showing and user is typing
            const dialogShowing = document.getElementById('exitDialog').classList.contains('show');
            const isTypingInInput = document.activeElement.tagName === 'INPUT';
            
            if ((e.key === 'q' || e.key === 'Q') && !dialogShowing && !isTypingInInput) {
                e.preventDefault();
                showExitDialog();
                // Clear the input after a small delay to prevent 'q' from appearing
                setTimeout(() => {
                    document.getElementById('screenLockCode').value = '';
                    document.getElementById('screenLockCode').focus();
                }, 10);
            } else if (e.key === 'Escape') {
                if (dialogShowing) {
                    cancelExit();
                }
            }
        });
        
        // New game dialog functions
        function cancelNewGame() {
            document.getElementById('newGameDialog').style.display = 'none';
        }
        
        function confirmNewGame() {
            document.getElementById('newGameDialog').style.display = 'none';
            
            // Notify backend about new game
            fetch('/solitaire/api/new/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({ action: 'new_game' })
                }).then(response => response.json()).then(data => {
                    if (data.game_state) {
                        // Use new game state from backend
                        const state = data.game_state;
                        game.stock = state.stock.map(convertCard);
                        game.waste = state.waste.map(convertCard);
                        game.foundations = [[], [], [], []];
                        game.tableau = state.tableau.map(pile => pile.map(convertCard));
                        game.score = 0;
                        game.moves = 0;
                        
                        // Reset timer
                        startTimer();
                        
                        // Update UI
                        document.getElementById('score').textContent = '0';
                        document.getElementById('moves').textContent = '0';
                        
                        render();
                    }
                }).catch(err => {
                    console.error('New game error:', err);
                    // Fallback to client-side new game
                    createNewGameLocal();
                });
        }
        
        // Button function to show new game dialog
        function newGame() {
            document.getElementById('newGameDialog').style.display = 'flex';
        }
        
        function createNewGameLocal() {
            // Reset game state and create new game locally
            game = {
                deck: [],
                stock: [],
                waste: [],
                foundations: [[], [], [], []],
                tableau: [[], [], [], [], [], [], []],
                score: 0,
                moves: 0
            };
            
            // Create new deck
            for (let s = 0; s < 4; s++) {
                for (let r = 0; r < 13; r++) {
                    game.deck.push({
                        suit: s,
                        rank: ranks[r],
                        value: values[ranks[r]] || parseInt(ranks[r]),
                        color: (s === 1 || s === 2) ? 'red' : 'black',
                        faceUp: false
                    });
                }
            }
            
            // Shuffle
            for (let i = game.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [game.deck[i], game.deck[j]] = [game.deck[j], game.deck[i]];
            }
            
            // Deal cards
            let cardIndex = 0;
            for (let col = 0; col < 7; col++) {
                for (let row = 0; row <= col; row++) {
                    const card = game.deck[cardIndex++];
                    card.faceUp = (row === col);
                    game.tableau[col].push(card);
                }
            }
            
            // Rest to stock
            while (cardIndex < game.deck.length) {
                game.stock.push(game.deck[cardIndex++]);
            }
            
            // Reset timer
            startTimer();
            
            // Update UI
            document.getElementById('score').textContent = '0';
            document.getElementById('moves').textContent = '0';
            
            render();
            saveGameState();
        }
        
        function undoMove() {
            console.log('Undo not implemented yet');
        }
        
        function showHint() {
            console.log('Auto-play not implemented yet');
        }
    </script>
</body>
</html>